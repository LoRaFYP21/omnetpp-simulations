[General]
# network
	network = LoRaMesh
	LoRaMesh.mapPath = "map/blu"
#	LoRaMesh.mapPath = "background/green"
	LoRaMesh.mapWidth = 20000 # width of the image of your map in meters
	LoRaMesh.mapHeight = 20000 # height of the image of your map in meters
	
#repeat
#	repeat = 25

# =================================================================
# ENHANCED LOGGING FOR ROUTING OBSERVATION
# =================================================================
	record-eventlog=true	    # Enable for detailed packet tracing

	cmdenv-status-frequency = 10s   # Status every 10 seconds for demo
	cmdenv-output-file = routing_demo_log.txt
	cmdenv-autoflush = true
	cmdenv-express-mode = false      # Disable for better observation
    **.vector-recording = true
	**.scalar-recording = true       # Enable for routing statistics

# random numbers generator

	rng-class = "cMersenneTwister"
	seed-set = ${processid}   # Use OS process id so positions vary each run

# simulation timing
	
	simtime-resolution = -10
	sim-time-limit = 500s     # Sufficient time for routing + data transmission
	**.loRaNodes[*].**.stopRoutingAfterDataDone = 500s
	**.loRaEndNodes[*].**.stopRoutingAfterDataDone = 500s

	
	warmup-period = 0s          # No warmup - start immediately!

# =================================================================
# 50-NODE GRID DEPLOYMENT FOR ROUTING DEMONSTRATION
# =================================================================
# Grid arrangement: 50 nodes in 8x7 grid (7 columns, 8 rows, missing 6 nodes)
# Area: 20km x 20km with sufficient spacing for multi-hop communication
# Grid spacing: ~2.5km between nodes for realistic LoRa range

# Grid parameters
**.loRaNodes[*].deploymentType = "grid"
**.loRaNodes[*].minX = 1000m           # Start 1km from edge
**.loRaNodes[*].minY = 1000m           # Start 1km from edge  
**.loRaNodes[*].sepX = 2500m           # 2.5km horizontal spacing
**.loRaNodes[*].sepY = 2500m           # 2.5km vertical spacing

# Manual positioning for 50 nodes in 8x7 grid pattern
# Row 0 (7 nodes): 0-6
**.loRaNodes[0].initialX = 1000m
**.loRaNodes[0].initialY = 1000m
**.loRaNodes[1].initialX = 3500m
**.loRaNodes[1].initialY = 1000m
**.loRaNodes[2].initialX = 6000m
**.loRaNodes[2].initialY = 1000m
**.loRaNodes[3].initialX = 8500m
**.loRaNodes[3].initialY = 1000m
**.loRaNodes[4].initialX = 11000m
**.loRaNodes[4].initialY = 1000m
**.loRaNodes[5].initialX = 13500m
**.loRaNodes[5].initialY = 1000m
**.loRaNodes[6].initialX = 16000m
**.loRaNodes[6].initialY = 1000m

# Row 1 (7 nodes): 7-13
**.loRaNodes[7].initialX = 1000m
**.loRaNodes[7].initialY = 3500m
**.loRaNodes[8].initialX = 3500m
**.loRaNodes[8].initialY = 3500m
**.loRaNodes[9].initialX = 6000m
**.loRaNodes[9].initialY = 3500m
**.loRaNodes[10].initialX = 8500m
**.loRaNodes[10].initialY = 3500m
**.loRaNodes[11].initialX = 11000m
**.loRaNodes[11].initialY = 3500m
**.loRaNodes[12].initialX = 13500m
**.loRaNodes[12].initialY = 3500m
**.loRaNodes[13].initialX = 16000m
**.loRaNodes[13].initialY = 3500m

# Row 2 (7 nodes): 14-20
**.loRaNodes[14].initialX = 1000m
**.loRaNodes[14].initialY = 6000m
**.loRaNodes[15].initialX = 3500m
**.loRaNodes[15].initialY = 6000m
**.loRaNodes[16].initialX = 6000m
**.loRaNodes[16].initialY = 6000m
**.loRaNodes[17].initialX = 8500m
**.loRaNodes[17].initialY = 6000m
**.loRaNodes[18].initialX = 11000m
**.loRaNodes[18].initialY = 6000m
**.loRaNodes[19].initialX = 13500m
**.loRaNodes[19].initialY = 6000m
**.loRaNodes[20].initialX = 16000m
**.loRaNodes[20].initialY = 6000m

# Row 3 (7 nodes): 21-27
**.loRaNodes[21].initialX = 1000m
**.loRaNodes[21].initialY = 8500m
**.loRaNodes[22].initialX = 3500m
**.loRaNodes[22].initialY = 8500m
**.loRaNodes[23].initialX = 6000m
**.loRaNodes[23].initialY = 8500m
**.loRaNodes[24].initialX = 8500m
**.loRaNodes[24].initialY = 8500m
**.loRaNodes[25].initialX = 11000m
**.loRaNodes[25].initialY = 8500m
**.loRaNodes[26].initialX = 13500m
**.loRaNodes[26].initialY = 8500m
**.loRaNodes[27].initialX = 16000m
**.loRaNodes[27].initialY = 8500m

# Row 4 (7 nodes): 28-34
**.loRaNodes[28].initialX = 1000m
**.loRaNodes[28].initialY = 11000m
**.loRaNodes[29].initialX = 3500m
**.loRaNodes[29].initialY = 11000m
**.loRaNodes[30].initialX = 6000m
**.loRaNodes[30].initialY = 11000m
**.loRaNodes[31].initialX = 8500m
**.loRaNodes[31].initialY = 11000m
**.loRaNodes[32].initialX = 11000m
**.loRaNodes[32].initialY = 11000m
**.loRaNodes[33].initialX = 13500m
**.loRaNodes[33].initialY = 11000m
**.loRaNodes[34].initialX = 16000m
**.loRaNodes[34].initialY = 11000m

# Row 5 (7 nodes): 35-41
**.loRaNodes[35].initialX = 1000m
**.loRaNodes[35].initialY = 13500m
**.loRaNodes[36].initialX = 3500m
**.loRaNodes[36].initialY = 13500m
**.loRaNodes[37].initialX = 6000m
**.loRaNodes[37].initialY = 13500m
**.loRaNodes[38].initialX = 8500m
**.loRaNodes[38].initialY = 13500m
**.loRaNodes[39].initialX = 11000m
**.loRaNodes[39].initialY = 13500m
**.loRaNodes[40].initialX = 13500m
**.loRaNodes[40].initialY = 13500m
**.loRaNodes[41].initialX = 16000m
**.loRaNodes[41].initialY = 13500m

# Row 6 (7 nodes): 42-48
**.loRaNodes[42].initialX = 1000m
**.loRaNodes[42].initialY = 16000m
**.loRaNodes[43].initialX = 3500m
**.loRaNodes[43].initialY = 16000m
**.loRaNodes[44].initialX = 6000m
**.loRaNodes[44].initialY = 16000m
**.loRaNodes[45].initialX = 8500m
**.loRaNodes[45].initialY = 16000m
**.loRaNodes[46].initialX = 11000m
**.loRaNodes[46].initialY = 16000m
**.loRaNodes[47].initialX = 13500m
**.loRaNodes[47].initialY = 16000m
**.loRaNodes[48].initialX = 16000m
**.loRaNodes[48].initialY = 16000m

# Row 7 (1 node): 49 (center node for interesting routing patterns)
**.loRaNodes[49].initialX = 8500m
**.loRaNodes[49].initialY = 18500m

	
# Number of nodes - 50 relay nodes in grid formation
**.numberOfNodes = 50         # 50 relay nodes for comprehensive routing demo
**.numberOfEndNodes = 2       # Two END nodes for this scenario
# power consumption features
**.loRaNodes[*].LoRaNic.radio.energyConsumerType = "LoRaEnergyConsumer"
**.loRaNodes[*].**.energySourceModule = "IdealEpEnergyStorage"
**.loRaNodes[*].LoRaNic.radio.energyConsumer.configFile = xmldoc("energyConsumptionParameters.xml")
**.loRaEndNodes[*].LoRaNic.radio.energyConsumerType = "LoRaEnergyConsumer"
**.loRaEndNodes[*].**.energySourceModule = "IdealEpEnergyStorage"
**.loRaEndNodes[*].LoRaNic.radio.energyConsumer.configFile = xmldoc("energyConsumptionParameters.xml")

# general network features
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
**.constraintAreaMaxX = 20000m  # 20km x 20km area
**.constraintAreaMaxY = 20000m
**.constraintAreaMaxZ = 0m
**.delayer.config = xmldoc("cloudDelays.xml")
**.radio.radioMediumModule = "LoRaMedium"
**.LoRaMedium.pathLossType = "LoRaLogNormalShadowing"

**.d0=190m
**.sigma = 3.5
**.gamma = 3.3

**.minInterferenceTime = 0s

# network features
**.numberOfGateways = 0

# =================================================================
# COMMUNICATION PATTERN FOR ROUTING DEMONSTRATION  
# =================================================================

# -----------------------------------------------------------------
# AUTOMATIC ACK FUNCTIONALITY
# When a DATA packet reaches its destination node, the destination
# will automatically generate an ACK packet back to the source using
# the routing tables. ACK packets are forwarded by intermediate nodes
# just like DATA packets, using the same routing algorithms.
# This enables end-to-end acknowledgment in multi-hop scenarios.
# -----------------------------------------------------------------

# data packets generation - disable relay generation, only end nodes communicate
**.sendPacketsContinuously = false #relay nodes don't generate packets

# ROUTING DEMO: Disable relay data generation, only end-to-end communication
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = false  #relays don't generate data packets

# COMMUNICATION :
**.numberOfDestinationsPerNode = 1 #Each node talks to 1 specific destination
**.dataPacketDefaultSize = 11B  #packet size
**.packetTTL = 20 #Sufficient TTL for long multi-hop paths

**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 60s    # Start data after 1 minute
**.loRaEndNodes[*].LoRaNodeApp.timeToFirstDataPacket = 60s    # Align end-node data start

**.timeToNextDataPacketDist = "uniform"
**.timeToNextDataPacketMin = 0s

**.timeToNextDataPacketMax = ${timeToNextDataPacketMax=10s}  # data packets are created every 1-10Secs

**.timeToNextDataPacketAvg = 5s   # Data every 5 seconds for easy observation

# forwarded packets
**.numberOfPacketsToForward = 0 #0 for no limit
**.ownDataPriority = 0 #0: forward priority; 1: own data priority

**.loRaNodes[*].LoRaNodeApp.routingMetric = 3  # HOP_COUNT routing - relay nodes use unicast with routing tables

# routing settings - ENHANCED FOR ROUTING DEMO
**.routeDiscovery = true
**.routeTimeout = 600s                 # Longer route validity for stability
**.storeBestRouteOnly = true           # Keep only the best route per destination
**.getRoutesFromDataPackets = true    # Learn from all packets
**.routingPacketPriority = 0.5
**.routingPacketMaxSize = 12B
**.timeToFirstRoutingPacket = 5s+uniform(0s, 5s)   # Start routing discovery immediately
**.timeToNextRoutingPacketDist = "uniform"
**.timeToNextRoutingPacketMin = 0s
**.timeToNextRoutingPacketMax = 10s    # Very frequent routing updates
**.timeToNextRoutingPacketAvg = 5s

# -----------------------------------------------------------------
# ROUTING TABLE FREEZE (stabilize topology after convergence)
# When enabled, once a node learns routingFreezeUniqueCount unique
# destination entries in its single-metric routing table, it will:
#  - Log REACHED<threshold> and FREEZE events to delivered_packets/routing_convergence.csv
#  - Stop accepting further routing updates / changes
#  - Preserve existing routes indefinitely (validity extended far future)
# This allows performance evaluation with a stable routing snapshot.
# Disable (false) to allow continuous adaptation.
# -----------------------------------------------------------------
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = true
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 51   # Require unique routes to all other 49 nodes
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s  # How long to keep frozen routes valid (avoid huge like 1e9s)
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true  # Stop routing beacons when all nodes have unique routes to all destinations

# duty cycle
**.dutyCycle = 0.01
**.enforceDutyCycle = ${enforceDutyCycle = true, false}

# nodes placement (overridden by individual positions above)
**.loRaNodes[*].minX = 0m
**.loRaNodes[*].minY = 0m
**.loRaNodes[*].maxX = 20000m 
**.loRaNodes[*].maxY = 20000m 

# Random placement for END nodes on every run (circle deployment)
**.loRaEndNodes[*].deploymentType = "circle"
**.loRaEndNodes[*].rad = 9000
**.loRaEndNodes[*].centX = 10000
**.loRaEndNodes[*].centY = 10000
**.loRaEndNodes[*].LoRaNodeApp.routingMetric = 3   # FIXED: End nodes use same routing as relays (HOP_COUNT) for proper unicast forwarding
**.loRaEndNodes[*].iAmEnd = true   # Mark as end nodes so 1000+ ID offset applies
 

**.LoRaMedium.mediumLimitCacheType = "LoRaMediumCache"
**.LoRaMedium.rangeFilter = "communicationRange"
**.LoRaMedium.neighborCacheType = "LoRaNeighborCache"
**.LoRaMedium.neighborCache.range = 3000m  # Suitable for 2.5km grid spacing
**.LoRaMedium.neighborCache.refillPeriod = 3000s

# LoRa settings: channel
**.loRaNodes[*].**.initFromDisplayString = false
**.loRaNodes[*].**initialLoRaSF = 7
**.loRaNodes[*].**minLoRaSF = 7
**.loRaNodes[*].**maxLoRaSF = 12
**.loRaNodes[*].**initialLoRaBW = 125 kHz
**.loRaNodes[*].**initialLoRaCR = 1
**.loRaNodes[*].**initialLoRaTP = 17dBm
**.loRaNodes[*].**initialLoRaCAD = true
**.loRaNodes[*].**initialLoRaCADatt = 0dB

# End-node radio initialization aligned with relay nodes
**.loRaEndNodes[*].**.initFromDisplayString = false
**.loRaEndNodes[*].**initialLoRaSF = 7
**.loRaEndNodes[*].**minLoRaSF = 7
**.loRaEndNodes[*].**maxLoRaSF = 12
**.loRaEndNodes[*].**initialLoRaBW = 125 kHz
**.loRaEndNodes[*].**initialLoRaCR = 1
**.loRaEndNodes[*].**initialLoRaTP = 17dBm
**.loRaEndNodes[*].**initialLoRaCAD = true
**.loRaEndNodes[*].**initialLoRaCADatt = 0dB

# =================================================================
# END-TO-END COMMUNICATION: Node 1000 floods to reach 1001
# End node 0 (ID 1000) continuously sends data to end node 1 (ID 1001)
# End nodes must use FLOODING (routingMetric=1) so the initial TX is broadcast.
# Relays also use FLOODING (routingMetric=1) to rebroadcast and propagate the packet.
# =================================================================
**.loRaEndNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true
**.loRaEndNodes[0].LoRaNodeApp.sendPacketsContinuously = true
**.loRaEndNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[0].LoRaNodeApp.forcedDestinationId = 1001
**.loRaEndNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 1
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 60s    # Start after minimal warmup
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 15s   # Send every 10-15 seconds  
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 12s

# Ensure all other end nodes don't generate traffic
**.loRaEndNodes[1].LoRaNodeApp.sendPacketsContinuously = false

# FLOODING MODE: ensure broadcast behavior
**.routeDiscovery = false                       # No routing beacons in flooding
**.loRaNodes[*].LoRaNodeApp.routingMetric = 1   # Relays flood/broadcast
**.loRaEndNodes[*].LoRaNodeApp.routingMetric = 1 # End nodes flood TX (no forwarding implied by iAmEnd + no-forward checks)

# =================================================================
# ROUTING ALGORITHM CONFIGURATIONS FOR EASY TESTING
# =================================================================

[Config HopCount_Routing] 
# Minimum hop count - Shortest path
**.loRaNodes[*].LoRaNodeApp.routingMetric = 3

[Config ETX_Routing]
# ETX (Expected Transmission Count) - reliability-based routing
**.loRaNodes[*].LoRaNodeApp.routingMetric = 6

[Config RSSI_Routing]
# RSSI-based routing - signal strength
**.loRaNodes[*].LoRaNodeApp.routingMetric = 4

# =================================================================
# QUICK DEMO CONFIGURATIONS
# =================================================================

[Config QuickDemo_HopCount_Grid50]
extends = HopCount_Routing  
# Ultra-fast hop count routing demo with 50-node grid
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 3s
**.timeToNextRoutingPacketAvg = 2s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 150s
**.timeToNextDataPacketMax = 8s
**.timeToNextDataPacketAvg = 5s
warmup-period = 0s
sim-time-limit = 2000s

# Communication pattern - corner to corner communication
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true     
**.numberOfDestinationsPerNode = 1
**.sendPacketsContinuously = false

# Corner-to-corner communication: node 0 (bottom-left) to node 48 (top-right)
**.loRaNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaNodes[0].LoRaNodeApp.forcedDestinationId = 5

# Routing freeze settings for grid
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false  # Disable for quick demo
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 49
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s
#-------------------------------------------------------------------------------------------

#[Config LongRange_Grid50]
#extends = ETX_Routing
# Long-range multi-hop communication across the entire grid
#**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = false
#**.sendPacketsContinuously = true
#**.timeToNextDataPacketMax = 30s
#**.timeToNextDataPacketAvg = 20s
#**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = uniform(60s, 120s)

# Multiple source-destination pairs for comprehensive testing
#**.loRaNodes[0].LoRaNodeApp.forceSingleDestination = true   # Bottom-left to top-right
#**.loRaNodes[0].LoRaNodeApp.forcedDestinationId = 48
#**.loRaNodes[6].LoRaNodeApp.forceSingleDestination = true   # Bottom-right to top-left  
#**.loRaNodes[6].LoRaNodeApp.forcedDestinationId = 42
#**.loRaNodes[24].LoRaNodeApp.forceSingleDestination = true  # Center to corner
#**.loRaNodes[24].LoRaNodeApp.forcedDestinationId = 49

#sim-time-limit = 2000s

# =================================================================
# REACHABILITY TEST: Node 0 to All Other Nodes (1-49)  
# =================================================================
[Config Node0ToAllNodes_Test]
extends = HopCount_Routing
# Test configuration to send packets from node 0 to every other node
# This will help identify which nodes are unreachable from node 0

# Only node 0 sends packets
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true     
**.numberOfDestinationsPerNode = 0  # 0 means all other nodes (auto-selected)
**.sendPacketsContinuously = true   # Keep sending packets

# Timing: Give routing time to converge, then start data transmission
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 50s
**.timeToNextRoutingPacketAvg = 45s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 150s     # Start data after routing converges

# Send packets with sufficient spacing
**.timeToNextDataPacketMax = 20s     # 10 seconds between packets 
**.timeToNextDataPacketAvg = 15s      # Average 8 seconds

# Routing settings optimized for reachability test
# Routing freeze settings for grid
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false  # Disable for quick demo
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 51
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s
**.routeTimeout = 800s               # Long route validity
**.packetTTL = 25                   # High TTL for long multi-hop paths

**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true  # Stop routing beacons when all nodes have unique routes to all destinations

# Extended simulation time to complete all transmissions
sim-time-limit = 2000s              # Shorter time first to test
warmup-period = 0s

# Duty cycle settings - disable to avoid interference with systematic testing
**.enforceDutyCycle = false         # Disable for comprehensive reachability test

# =================================================================
# SINGLE PACKET PER DESTINATION: Node 0 to All Other Nodes (1-49)  
# =================================================================
[Config Node0ToAllNodes_SinglePacket]
extends = HopCount_Routing
# Send exactly ONE packet from node 0 to each of the 49 destinations
# No continuous transmission - just one round of packets

# Only node 0 sends packets
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true     
**.numberOfDestinationsPerNode = 0  # 0 means all other nodes (auto-selected)
**.sendPacketsContinuously = false  # CRITICAL: Send only initial batch, no continuous packets
**.numberOfPacketsPerDestination = 1  # Exactly 1 packet per destination

# Use a different result file name to avoid conflicts
output-scalar-file = "Node0_SinglePacket_${configname}_${datetime}.sca"
output-vector-file = "Node0_SinglePacket_${configname}_${datetime}.vec"

# Timing: Give routing time to converge, then send all packets quickly
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 3s
**.timeToNextRoutingPacketAvg = 2s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 200s     # Start data after routing converges

# Since sendPacketsContinuously=false, these timing parameters won't be used for additional packets
**.timeToNextDataPacketMax = 10s      # Not used with sendPacketsContinuously=false
**.timeToNextDataPacketAvg = 10s      # Not used with sendPacketsContinuously=false

# Routing settings optimized for reachability test
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false  # Keep adapting for reliability
**.routeTimeout = 800s               # Long route validity
**.packetTTL = 25                   # High TTL for long multi-hop paths

# Shorter simulation time since we only send 49 packets total
sim-time-limit = 600s               # Sufficient time for all 49 packets to be delivered
warmup-period = 0s

# Duty cycle settings - disable to avoid interference with systematic testing
**.enforceDutyCycle = false         # Disable for single-packet reachability test

# =================================================================
# SIMPLE TEST: Node 0 to Specific Nodes (Manual Testing)
# =================================================================
[Config Node0ToNode5_Simple]
extends = HopCount_Routing
# Simple test to verify the configuration works - send from node 0 to node 10
# Ultra-fast hop count routing demo with 50-node grid
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 3s
**.timeToNextRoutingPacketAvg = 2s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 150s
**.timeToNextDataPacketMax = 8s
**.timeToNextDataPacketAvg = 5s
warmup-period = 0s
sim-time-limit = 2000s

**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true
**.numberOfDestinationsPerNode = 1
**.sendPacketsContinuously = false

**.loRaNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaNodes[0].LoRaNodeApp.forcedDestinationId = 5
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 16   # Adjust if you want earlier/later freeze
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s


#**.enforceDutyCycle = false

# =================================================================
# END-TO-END: End node 1000 continuously sends to End node 1001
# End nodes broadcast, relays forward using unicast routing tables
# =================================================================
[Config End1000_to_End1001]
extends = HopCount_Routing

# Keep routing behavior and logging as in base
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true

# Stop routing beacons after relay convergence; keep forwarding enabled
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = true
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 3
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true

# Enable continuous data generation from end node 0 (ID 1000) to end node 1 (ID 1001)
**.sendPacketsContinuously = false  # Relays don't generate data

# Disable data generation for relay nodes and unwanted end nodes
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 1e6s
**.loRaEndNodes[1].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Enable continuous data generation only at end node 0 (ID 1000)
**.loRaEndNodes[0].LoRaNodeApp.sendPacketsContinuously = true
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 150s
**.loRaEndNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[0].LoRaNodeApp.forcedDestinationId = 1001
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 20s
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 15s

# Longer simulation to observe multiple packet exchanges
sim-time-limit = 1000s

# Ensure end nodes participate in routing beacons so relays can learn routes to 1000/1001
**.loRaEndNodes[*].LoRaNodeApp.routingMetric = 3

# Timing for routing beacons so routes propagate before the data
**.timeToFirstRoutingPacket = 5s
**.timeToNextRoutingPacketMax = 10s
**.timeToNextRoutingPacketAvg = 5s

# Reasonable simulation time
sim-time-limit = 1200s
warmup-period = 0s

# =================================================================
# SMART BROADCAST: End1000 generates, relays smart-broadcast to End1001
# End nodes use routing metric 0 (no forwarding), relays use metric 2 (smart broadcast)
# No routing packets generated - pure data forwarding with duplicate avoidance
# =================================================================
[Config SmartBroadcast_End1000_to_End1001]
# Base network and node configuration
network = LoRaMesh
**.numberOfNodes = 50
**.numberOfEndNodes = 2

# Use same grid positioning as main config
**.loRaNodes[*].deploymentType = "grid"
**.loRaNodes[*].minX = 1000m
**.loRaNodes[*].minY = 1000m
**.loRaNodes[*].sepX = 2500m
**.loRaNodes[*].sepY = 2500m

# Manual positioning for 50 relay nodes (copy from main config)
**.loRaNodes[0].initialX = 1000m
**.loRaNodes[0].initialY = 1000m
**.loRaNodes[1].initialX = 3500m
**.loRaNodes[1].initialY = 1000m
**.loRaNodes[2].initialX = 6000m
**.loRaNodes[2].initialY = 1000m
**.loRaNodes[3].initialX = 8500m
**.loRaNodes[3].initialY = 1000m
**.loRaNodes[4].initialX = 11000m
**.loRaNodes[4].initialY = 1000m
**.loRaNodes[5].initialX = 13500m
**.loRaNodes[5].initialY = 1000m
**.loRaNodes[6].initialX = 16000m
**.loRaNodes[6].initialY = 1000m
**.loRaNodes[7].initialX = 1000m
**.loRaNodes[7].initialY = 3500m
**.loRaNodes[8].initialX = 3500m
**.loRaNodes[8].initialY = 3500m
**.loRaNodes[9].initialX = 6000m
**.loRaNodes[9].initialY = 3500m
**.loRaNodes[10].initialX = 8500m
**.loRaNodes[10].initialY = 3500m
**.loRaNodes[11].initialX = 11000m
**.loRaNodes[11].initialY = 3500m
**.loRaNodes[12].initialX = 13500m
**.loRaNodes[12].initialY = 3500m
**.loRaNodes[13].initialX = 16000m
**.loRaNodes[13].initialY = 3500m
**.loRaNodes[14].initialX = 1000m
**.loRaNodes[14].initialY = 6000m
**.loRaNodes[15].initialX = 3500m
**.loRaNodes[15].initialY = 6000m
**.loRaNodes[16].initialX = 6000m
**.loRaNodes[16].initialY = 6000m
**.loRaNodes[17].initialX = 8500m
**.loRaNodes[17].initialY = 6000m
**.loRaNodes[18].initialX = 11000m
**.loRaNodes[18].initialY = 6000m
**.loRaNodes[19].initialX = 13500m
**.loRaNodes[19].initialY = 6000m
**.loRaNodes[20].initialX = 16000m
**.loRaNodes[20].initialY = 6000m
**.loRaNodes[21].initialX = 1000m
**.loRaNodes[21].initialY = 8500m
**.loRaNodes[22].initialX = 3500m
**.loRaNodes[22].initialY = 8500m
**.loRaNodes[23].initialX = 6000m
**.loRaNodes[23].initialY = 8500m
**.loRaNodes[24].initialX = 8500m
**.loRaNodes[24].initialY = 8500m
**.loRaNodes[25].initialX = 11000m
**.loRaNodes[25].initialY = 8500m
**.loRaNodes[26].initialX = 13500m
**.loRaNodes[26].initialY = 8500m
**.loRaNodes[27].initialX = 16000m
**.loRaNodes[27].initialY = 8500m
**.loRaNodes[28].initialX = 1000m
**.loRaNodes[28].initialY = 11000m
**.loRaNodes[29].initialX = 3500m
**.loRaNodes[29].initialY = 11000m
**.loRaNodes[30].initialX = 6000m
**.loRaNodes[30].initialY = 11000m
**.loRaNodes[31].initialX = 8500m
**.loRaNodes[31].initialY = 11000m
**.loRaNodes[32].initialX = 11000m
**.loRaNodes[32].initialY = 11000m
**.loRaNodes[33].initialX = 13500m
**.loRaNodes[33].initialY = 11000m
**.loRaNodes[34].initialX = 16000m
**.loRaNodes[34].initialY = 11000m
**.loRaNodes[35].initialX = 1000m
**.loRaNodes[35].initialY = 13500m
**.loRaNodes[36].initialX = 3500m
**.loRaNodes[36].initialY = 13500m
**.loRaNodes[37].initialX = 6000m
**.loRaNodes[37].initialY = 13500m
**.loRaNodes[38].initialX = 8500m
**.loRaNodes[38].initialY = 13500m
**.loRaNodes[39].initialX = 11000m
**.loRaNodes[39].initialY = 13500m
**.loRaNodes[40].initialX = 13500m
**.loRaNodes[40].initialY = 13500m
**.loRaNodes[41].initialX = 16000m
**.loRaNodes[41].initialY = 13500m
**.loRaNodes[42].initialX = 1000m
**.loRaNodes[42].initialY = 16000m
**.loRaNodes[43].initialX = 3500m
**.loRaNodes[43].initialY = 16000m
**.loRaNodes[44].initialX = 6000m
**.loRaNodes[44].initialY = 16000m
**.loRaNodes[45].initialX = 8500m
**.loRaNodes[45].initialY = 16000m
**.loRaNodes[46].initialX = 11000m
**.loRaNodes[46].initialY = 16000m
**.loRaNodes[47].initialX = 13500m
**.loRaNodes[47].initialY = 16000m
**.loRaNodes[48].initialX = 16000m
**.loRaNodes[48].initialY = 16000m
**.loRaNodes[49].initialX = 8500m
**.loRaNodes[49].initialY = 18500m

# Random placement for END nodes (circle deployment)
**.loRaEndNodes[*].deploymentType = "circle"
**.loRaEndNodes[*].rad = 9000
**.loRaEndNodes[*].centX = 10000
**.loRaEndNodes[*].centY = 10000
**.loRaEndNodes[*].iAmEnd = true

# ROUTING METRICS: End nodes use routing metric 1 for ID offset, relays smart broadcast (2)  
**.loRaNodes[*].LoRaNodeApp.routingMetric = 2      # SMART_BROADCAST_SINGLE_SF for relays
**.loRaEndNodes[*].LoRaNodeApp.routingMetric = 1   # Use FLOODING to get +1000 ID offset, but won't forward due to isEndNodeHost() checks

# DISABLE ALL ROUTING PACKET GENERATION - no routing tables needed
**.routeDiscovery = false
**.loRaNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 1e6s    # Effectively disable
**.loRaEndNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 1e6s # Effectively disable
**.timeToNextRoutingPacketMax = 1e6s                          # Effectively disable
**.timeToNextRoutingPacketAvg = 1e6s                          # Effectively disable

# DATA GENERATION: Only end node 0 (ID 1000) generates packets to end node 1 (ID 1001)
**.sendPacketsContinuously = false
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = false     # Relays don't generate data
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 1e6s      # Relays never generate data

# End node 0 generates continuous data packets to end node 1
**.loRaEndNodes[0].LoRaNodeApp.sendPacketsContinuously = true
**.loRaEndNodes[0].LoRaNodeApp.onlyNode0SendsPackets = true
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 10s
**.loRaEndNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[0].LoRaNodeApp.forcedDestinationId = 1001
**.loRaEndNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 15s
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 10s

# End node 1 doesn't generate any data packets
**.loRaEndNodes[1].LoRaNodeApp.sendPacketsContinuously = false
**.loRaEndNodes[1].LoRaNodeApp.onlyNode0SendsPackets = false
**.loRaEndNodes[1].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# PACKET PARAMETERS
**.dataPacketDefaultSize = 11B
**.packetTTL = 30                    # Sufficient TTL for multi-hop broadcast
**.numberOfPacketsPerDestination = 1 # Generate at least 1 packet per destination for continuous sending

# LOGGING AND SIMULATION SETTINGS
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true
cmdenv-express-mode = false
cmdenv-autoflush = true
sim-time-limit = 600s                # 10 minutes for observing broadcast behavior
warmup-period = 0s

# RADIO SETTINGS (inherit from main config)
**.loRaNodes[*].**initialLoRaSF = 7
**.loRaNodes[*].**initialLoRaBW = 125 kHz
**.loRaNodes[*].**initialLoRaTP = 17dBm
**.loRaEndNodes[*].**initialLoRaSF = 7
**.loRaEndNodes[*].**initialLoRaBW = 125 kHz
**.loRaEndNodes[*].**initialLoRaTP = 17dBm

# NETWORK SETTINGS
**.constraintAreaMaxX = 20000m
**.constraintAreaMaxY = 20000m
**.LoRaMedium.pathLossType = "LoRaLogNormalShadowing"
**.sigma = 3.5
**.gamma = 3.3
**.LoRaMedium.neighborCache.range = 3700m  # Increased for better diagonal connectivity

# DUTY CYCLE
**.dutyCycle = 0.01
**.enforceDutyCycle = true
