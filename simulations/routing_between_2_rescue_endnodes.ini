[General]
# network
	network = LoRaMesh
	LoRaMesh.mapPath = "map/blu"
#	LoRaMesh.mapPath = "background/green"
	LoRaMesh.mapWidth = 20000 # width of the image of your map in meters
	LoRaMesh.mapHeight = 20000 # height of the image of your map in meters
	
#repeat
#	repeat = 25

# =================================================================
# ENHANCED LOGGING FOR ROUTING OBSERVATION
# =================================================================
	record-eventlog=true	    # Enable for detailed packet tracing

	cmdenv-status-frequency = 10s   # Status every 10 seconds for demo
	cmdenv-output-file = routing_demo_log.txt
	cmdenv-autoflush = true
	cmdenv-express-mode = false      # Disable for better observation
    **.vector-recording = true
	**.scalar-recording = true       # Enable for routing statistics

# random numbers generator

	rng-class = "cMersenneTwister"
	seed-set = ${processid}   # Use OS process id so positions vary each run

# simulation timing
	
	simtime-resolution = -10
	sim-time-limit = 500s     # Sufficient time for routing + data transmission
	**.loRaNodes[*].**.stopRoutingAfterDataDone = 500s
	**.loRaRescueNodes[*].**.stopRoutingAfterDataDone = 500s

	
	warmup-period = 0s          # No warmup - start immediately!

# =================================================================
# 50-NODE GRID DEPLOYMENT FOR ROUTING DEMONSTRATION
# =================================================================
# Grid arrangement: 50 nodes in 8x7 grid (7 columns, 8 rows, missing 6 nodes)
# Area: 20km x 20km with sufficient spacing for multi-hop communication
# Grid spacing: ~2.5km between nodes for realistic LoRa range

# Grid parameters
**.loRaNodes[*].deploymentType = "grid"
**.loRaNodes[*].minX = 1000m           # Start 1km from edge
**.loRaNodes[*].minY = 1000m           # Start 1km from edge  
**.loRaNodes[*].sepX = 2500m           # 2.5km horizontal spacing
**.loRaNodes[*].sepY = 2500m           # 2.5km vertical spacing

# Manual positioning for 50 nodes in 8x7 grid pattern
# Row 0 (7 nodes): 0-6
**.loRaNodes[0].initialX = 1000m
**.loRaNodes[0].initialY = 1000m
**.loRaNodes[1].initialX = 3500m
**.loRaNodes[1].initialY = 1000m
**.loRaNodes[2].initialX = 6000m
**.loRaNodes[2].initialY = 1000m
**.loRaNodes[3].initialX = 8500m
**.loRaNodes[3].initialY = 1000m
**.loRaNodes[4].initialX = 11000m
**.loRaNodes[4].initialY = 1000m
**.loRaNodes[5].initialX = 13500m
**.loRaNodes[5].initialY = 1000m
**.loRaNodes[6].initialX = 16000m
**.loRaNodes[6].initialY = 1000m

# Row 1 (7 nodes): 7-13
**.loRaNodes[7].initialX = 1000m
**.loRaNodes[7].initialY = 3500m
**.loRaNodes[8].initialX = 3500m
**.loRaNodes[8].initialY = 3500m
**.loRaNodes[9].initialX = 6000m
**.loRaNodes[9].initialY = 3500m
**.loRaNodes[10].initialX = 8500m
**.loRaNodes[10].initialY = 3500m
**.loRaNodes[11].initialX = 11000m
**.loRaNodes[11].initialY = 3500m
**.loRaNodes[12].initialX = 13500m
**.loRaNodes[12].initialY = 3500m
**.loRaNodes[13].initialX = 16000m
**.loRaNodes[13].initialY = 3500m

# Row 2 (7 nodes): 14-20
**.loRaNodes[14].initialX = 1000m
**.loRaNodes[14].initialY = 6000m
**.loRaNodes[15].initialX = 3500m
**.loRaNodes[15].initialY = 6000m
**.loRaNodes[16].initialX = 6000m
**.loRaNodes[16].initialY = 6000m
**.loRaNodes[17].initialX = 8500m
**.loRaNodes[17].initialY = 6000m
**.loRaNodes[18].initialX = 11000m
**.loRaNodes[18].initialY = 6000m
**.loRaNodes[19].initialX = 13500m
**.loRaNodes[19].initialY = 6000m
**.loRaNodes[20].initialX = 16000m
**.loRaNodes[20].initialY = 6000m

# Row 3 (7 nodes): 21-27
**.loRaNodes[21].initialX = 1000m
**.loRaNodes[21].initialY = 8500m
**.loRaNodes[22].initialX = 3500m
**.loRaNodes[22].initialY = 8500m
**.loRaNodes[23].initialX = 6000m
**.loRaNodes[23].initialY = 8500m
**.loRaNodes[24].initialX = 8500m
**.loRaNodes[24].initialY = 8500m
**.loRaNodes[25].initialX = 11000m
**.loRaNodes[25].initialY = 8500m
**.loRaNodes[26].initialX = 13500m
**.loRaNodes[26].initialY = 8500m
**.loRaNodes[27].initialX = 16000m
**.loRaNodes[27].initialY = 8500m

# Row 4 (7 nodes): 28-34
**.loRaNodes[28].initialX = 1000m
**.loRaNodes[28].initialY = 11000m
**.loRaNodes[29].initialX = 3500m
**.loRaNodes[29].initialY = 11000m
**.loRaNodes[30].initialX = 6000m
**.loRaNodes[30].initialY = 11000m
**.loRaNodes[31].initialX = 8500m
**.loRaNodes[31].initialY = 11000m
**.loRaNodes[32].initialX = 11000m
**.loRaNodes[32].initialY = 11000m
**.loRaNodes[33].initialX = 13500m
**.loRaNodes[33].initialY = 11000m
**.loRaNodes[34].initialX = 16000m
**.loRaNodes[34].initialY = 11000m

# Row 5 (7 nodes): 35-41
**.loRaNodes[35].initialX = 1000m
**.loRaNodes[35].initialY = 13500m
**.loRaNodes[36].initialX = 3500m
**.loRaNodes[36].initialY = 13500m
**.loRaNodes[37].initialX = 6000m
**.loRaNodes[37].initialY = 13500m
**.loRaNodes[38].initialX = 8500m
**.loRaNodes[38].initialY = 13500m
**.loRaNodes[39].initialX = 11000m
**.loRaNodes[39].initialY = 13500m
**.loRaNodes[40].initialX = 13500m
**.loRaNodes[40].initialY = 13500m
**.loRaNodes[41].initialX = 16000m
**.loRaNodes[41].initialY = 13500m

# Row 6 (7 nodes): 42-48
**.loRaNodes[42].initialX = 1000m
**.loRaNodes[42].initialY = 16000m
**.loRaNodes[43].initialX = 3500m
**.loRaNodes[43].initialY = 16000m
**.loRaNodes[44].initialX = 6000m
**.loRaNodes[44].initialY = 16000m
**.loRaNodes[45].initialX = 8500m
**.loRaNodes[45].initialY = 16000m
**.loRaNodes[46].initialX = 11000m
**.loRaNodes[46].initialY = 16000m
**.loRaNodes[47].initialX = 13500m
**.loRaNodes[47].initialY = 16000m
**.loRaNodes[48].initialX = 16000m
**.loRaNodes[48].initialY = 16000m

# Row 7 (1 node): 49 (center node for interesting routing patterns)
**.loRaNodes[49].initialX = 8500m
**.loRaNodes[49].initialY = 18500m

	
# Number of nodes - 50 relay nodes in grid formation
**.numberOfNodes = 50         # 50 relay nodes for comprehensive routing demo
**.numberOfEndNodes = 0       # No regular end nodes (using rescue nodes instead)
**.numberOfRescueNodes = 2    # Two RESCUE end nodes for this scenario
# power consumption features
**.loRaNodes[*].LoRaNic.radio.energyConsumerType = "LoRaEnergyConsumer"
**.loRaNodes[*].**.energySourceModule = "IdealEpEnergyStorage"
**.loRaNodes[*].LoRaNic.radio.energyConsumer.configFile = xmldoc("energyConsumptionParameters.xml")
**.loRaRescueNodes[*].LoRaNic.radio.energyConsumerType = "LoRaEnergyConsumer"
**.loRaRescueNodes[*].**.energySourceModule = "IdealEpEnergyStorage"
**.loRaRescueNodes[*].LoRaNic.radio.energyConsumer.configFile = xmldoc("energyConsumptionParameters.xml")

# general network features
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
**.constraintAreaMaxX = 20000m  # 20km x 20km area
**.constraintAreaMaxY = 20000m
**.constraintAreaMaxZ = 0m
**.delayer.config = xmldoc("cloudDelays.xml")
**.radio.radioMediumModule = "LoRaMedium"
**.LoRaMedium.pathLossType = "LoRaLogNormalShadowing"

**.d0=190m
**.sigma = 3.5
**.gamma = 3.3

**.minInterferenceTime = 0s

# network features
**.numberOfGateways = 0

# =================================================================
# COMMUNICATION PATTERN FOR ROUTING DEMONSTRATION  
# =================================================================

# -----------------------------------------------------------------
# AUTOMATIC ACK FUNCTIONALITY
# When a DATA packet reaches its destination node, the destination
# will automatically generate an ACK packet back to the source using
# the routing tables. ACK packets are forwarded by intermediate nodes
# just like DATA packets, using the same routing algorithms.
# This enables end-to-end acknowledgment in multi-hop scenarios.
# -----------------------------------------------------------------

# data packets generation - disable relay generation, only rescue end nodes communicate
**.sendPacketsContinuously = false #relay nodes don't generate packets

# ROUTING DEMO: Disable relay data generation, only end-to-end communication
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = false  #relays don't generate data packets

# COMMUNICATION :
**.numberOfDestinationsPerNode = 1 #Each node talks to 1 specific destination
**.dataPacketDefaultSize = 11B  #packet size
**.packetTTL = 20 #Sufficient TTL for long multi-hop paths

**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 60s    # Start data after 1 minute
**.loRaRescueNodes[*].LoRaNodeApp.timeToFirstDataPacket = 60s    # Align end-node data start

**.timeToNextDataPacketDist = "uniform"
**.timeToNextDataPacketMin = 0s

**.timeToNextDataPacketMax = ${timeToNextDataPacketMax=10s}  # data packets are created every 1-10Secs

**.timeToNextDataPacketAvg = 5s   # Data every 5 seconds for easy observation

# forwarded packets
**.numberOfPacketsToForward = 0 #0 for no limit
**.ownDataPriority = 0 #0: forward priority; 1: own data priority

**.loRaNodes[*].LoRaNodeApp.routingMetric = 3  # HOP_COUNT routing - relay nodes use unicast with routing tables

# routing settings - ENHANCED FOR ROUTING DEMO
**.routeDiscovery = true
**.routeTimeout = 600s                 # Longer route validity for stability
**.storeBestRouteOnly = true           # Keep only the best route per destination
**.getRoutesFromDataPackets = true    # Learn from all packets
**.routingPacketPriority = 0.5
**.routingPacketMaxSize = 12B
**.timeToFirstRoutingPacket = 5s+uniform(0s, 5s)   # Start routing discovery immediately
**.timeToNextRoutingPacketDist = "uniform"
**.timeToNextRoutingPacketMin = 0s
**.timeToNextRoutingPacketMax = 10s    # Very frequent routing updates
**.timeToNextRoutingPacketAvg = 5s

# -----------------------------------------------------------------
# ROUTING TABLE FREEZE (stabilize topology after convergence)
# When enabled, once a node learns routingFreezeUniqueCount unique
# destination entries in its single-metric routing table, it will:
#  - Log REACHED<threshold> and FREEZE events to delivered_packets/routing_convergence.csv
#  - Stop accepting further routing updates / changes
#  - Preserve existing routes indefinitely (validity extended far future)
# This allows performance evaluation with a stable routing snapshot.
# Disable (false) to allow uous adaptation.
# -----------------------------------------------------------------
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = true
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 51   # Require unique routes to all other 49 nodes
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s  # How long to keep frozen routes valid (avoid huge like 1e9s)
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true  # Stop routing beacons when all nodes have unique routes to all destinations

# duty cycle
**.dutyCycle = 0.01
**.enforceDutyCycle = ${enforceDutyCycle = true, false}

# nodes placement (overridden by individual positions above)
**.loRaNodes[*].minX = 0m
**.loRaNodes[*].minY = 0m
**.loRaNodes[*].maxX = 20000m 
**.loRaNodes[*].maxY = 20000m 

# Random placement for RESCUE end nodes on every run (circle deployment)
**.loRaRescueNodes[*].deploymentType = "circle"
**.loRaRescueNodes[*].rad = 9000
**.loRaRescueNodes[*].centX = 10000
**.loRaRescueNodes[*].centY = 10000
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 3   # End nodes use same routing as relays (HOP_COUNT) for proper unicast forwarding
**.loRaRescueNodes[*].iAmRescue = true   # Identify rescue nodes; nodeId offsets to 2000+
 



**.LoRaMedium.mediumLimitCacheType = "LoRaMediumCache"
**.LoRaMedium.rangeFilter = "communicationRange"
**.LoRaMedium.neighborCacheType = "LoRaNeighborCache"
**.LoRaMedium.neighborCache.range = 3000m  # Suitable for 2.5km grid spacing
**.LoRaMedium.neighborCache.refillPeriod = 3000s

# LoRa settings: channel
**.loRaNodes[*].**.initFromDisplayString = false
**.loRaNodes[*].**initialLoRaSF = 7
**.loRaNodes[*].**minLoRaSF = 7
**.loRaNodes[*].**maxLoRaSF = 12
**.loRaNodes[*].**initialLoRaBW = 125 kHz
**.loRaNodes[*].**initialLoRaCR = 1
**.loRaNodes[*].**initialLoRaTP = 17dBm
**.loRaNodes[*].**initialLoRaCAD = true
**.loRaNodes[*].**initialLoRaCADatt = 0dB

# Rescue end-node radio initialization aligned with relay nodes
**.loRaRescueNodes[*].**.initFromDisplayString = false
**.loRaRescueNodes[*].**initialLoRaSF = 7
**.loRaRescueNodes[*].**minLoRaSF = 7
**.loRaRescueNodes[*].**maxLoRaSF = 12
**.loRaRescueNodes[*].**initialLoRaBW = 125 kHz
**.loRaRescueNodes[*].**initialLoRaCR = 1
**.loRaRescueNodes[*].**initialLoRaTP = 17dBm
**.loRaRescueNodes[*].**initialLoRaCAD = true
**.loRaRescueNodes[*].**initialLoRaCADatt = 0dB

# =================================================================
# END-TO-END COMMUNICATION: Rescue node 2000 floods to reach 2001
# Rescue end node 0 (ID 2000) continuously sends data to rescue end node 1 (ID 2001)
# End nodes must use FLOODING (routingMetric=1) so the initial TX is broadcast.
# Relays also use FLOODING (routingMetric=1) to rebroadcast and propagate the packet.
# =================================================================
**.loRaRescueNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true
**.loRaRescueNodes[0].LoRaNodeApp.sendPacketsContinuously = true
**.loRaRescueNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaRescueNodes[0].LoRaNodeApp.forcedDestinationId = 2001
**.loRaRescueNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaRescueNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 1
**.loRaRescueNodes[0].LoRaNodeApp.timeToFirstDataPacket = 60s    # Start after minimal warmup
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 15s   # Send every 10-15 seconds  
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 12s

# Ensure the other rescue end node doesn't generate traffic
**.loRaRescueNodes[1].LoRaNodeApp.sendPacketsContinuously = false

# FLOODING MODE: ensure broadcast behavior
**.routeDiscovery = false                       # No routing beacons in flooding
**.loRaNodes[*].LoRaNodeApp.routingMetric = 1   # Relays flood/broadcast
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 1 # End nodes flood TX (no forwarding implied by iAmEnd + no-forward checks)

# =================================================================
# ROUTING ALGORITHM CONFIGURATIONS FOR EASY TESTING
# =================================================================

[Config HopCount_Routing] 
# Minimum hop count - Shortest path
**.loRaNodes[*].LoRaNodeApp.routingMetric = 3

# =================================================================

# =================================================================
# END NODE → RESCUE NODE: Single packet from end node (ID 1000) to rescue (ID 2000)
# - Adds one classic end node (`endNode` using `LoRaNodeApp`) alongside rescue nodes
# - Uses hop-count routing so relays learn unicast routes before data
# - End node sends exactly one packet to the first rescue node
# =================================================================
[Config EndNode1000_to_Rescue2000]
extends = HopCount_Routing

# Keep routing behavior and logging as in base
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true

# Node counts: keep existing 50 relays, add 1 end node and 1 rescue node
network = LoRaMesh
**.numberOfNodes = 50
**.numberOfEndNodes = 1
**.numberOfRescueNodes = 1   # Need node IDs 2000 and 2001 (destination)

# Explicitly enable route discovery in this config (overrides any global flooding settings)
**.routeDiscovery = true
**.timeToFirstRoutingPacket = 5s
**.timeToNextRoutingPacketMax = 10s
**.timeToNextRoutingPacketAvg = 5s

# Ensure all three node types emit routing beacons with the same timers
**.loRaNodes[*].LoRaNodeApp.routeDiscovery = true
**.loRaNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 5s
**.loRaNodes[*].LoRaNodeApp.timeToNextRoutingPacketMax = 10s
**.loRaNodes[*].LoRaNodeApp.timeToNextRoutingPacketAvg = 5s

**.loRaRescueNodes[*].LoRaNodeApp.routeDiscovery = true
**.loRaRescueNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 5s
**.loRaRescueNodes[*].LoRaNodeApp.timeToNextRoutingPacketMax = 10s
**.loRaRescueNodes[*].LoRaNodeApp.timeToNextRoutingPacketAvg = 5s

**.loRaEndNodes[*].LoRaNodeApp.routeDiscovery = true
**.loRaEndNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 5s
**.loRaEndNodes[*].LoRaNodeApp.timeToNextRoutingPacketMax = 10s
**.loRaEndNodes[*].LoRaNodeApp.timeToNextRoutingPacketAvg = 5s


# Stop routing beacons after relay convergence; keep forwarding enabled
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = true
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 3
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true

**.loRaEndNodes[*].iAmEnd = true
**.loRaRescueNodes[*].iAmRescue = true

# Enable continuous data generation from end node 0 (ID 1000) to rescue node 1 (ID 1001)
**.sendPacketsContinuously = false  # Relays don't generate data
# Disable data generation for relay nodes and unwanted end nodes
#**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 1e6s
#**.loRaRescueNodes[1].LoRaNodeApp.timeToFirstDataPacket = 1e6s
**.loRaRescueNodes[0].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Power consumption features for end node (match relays/rescue nodes)
**.loRaEndNodes[*].LoRaNic.radio.energyConsumerType = "LoRaEnergyConsumer"
**.loRaEndNodes[*].**.energySourceModule = "IdealEpEnergyStorage"
**.loRaEndNodes[*].LoRaNic.radio.energyConsumer.configFile = xmldoc("energyConsumptionParameters.xml")

# Ensure end/rescue nodes participate in routing (unicast forwarding via relays)
**.loRaNodes[*].LoRaNodeApp.routingMetric = 3
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 3
**.loRaEndNodes[*].LoRaNodeApp.routingMetric = 3

# Prevent relays from generating data
**.sendPacketsContinuously = false
**.loRaNodes[*].LoRaNodeApp.sendPacketsContinuously = false
**.loRaNodes[*].LoRaNodeApp.numberOfPacketsPerDestination = 0
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Place the rescue node randomly on the circle each run
**.loRaRescueNodes[*].deploymentType = "circle"
**.loRaRescueNodes[*].rad = 9000
**.loRaRescueNodes[*].centX = 10000
**.loRaRescueNodes[*].centY = 10000
**.loRaRescueNodes[*].**.initFromDisplayString = false

# Random placement for END nodes on every run (circle deployment)
**.loRaEndNodes[*].deploymentType = "circle"
**.loRaEndNodes[*].rad = 9000
**.loRaEndNodes[*].centX = 10000
**.loRaEndNodes[*].centY = 10000


**.loRaNodes[*].LoRaNodeApp.recordPerPacketSignals = false
**.loRaRescueNodes[*].LoRaNodeApp.recordPerPacketSignals = false
**.loRaEndNodes[*].LoRaNodeApp.recordPerPacketSignals = false



# Make rescue nodes mobile (MassMobility), mirroring DV_End1000_to_End1001_Mobility
**.loRaRescueNodes[*].mobilityType = "MassMobility"
**.loRaRescueNodes[*].mobility.speed = uniform(3mps, 7mps)
**.loRaRescueNodes[*].mobility.changeInterval = 5s
**.loRaRescueNodes[*].mobility.changeAngleBy = normal(0deg, 30deg)  # Required parameter for MassMobility
**.loRaRescueNodes[*].mobility.initialX = 10000m + sqrt(uniform(0,1)) * 9000m * cos(uniform(0, 2*acos(-1)))
**.loRaRescueNodes[*].mobility.initialY = 10000m + sqrt(uniform(0,1)) * 9000m * sin(uniform(0, 2*acos(-1)))

**.loRaEndNodes[*].**.initFromDisplayString = false


# End node sends exactly one packet to the rescue node (ID 2000)
**.loRaEndNodes[0].LoRaNodeApp.sendPacketsContinuously = false
**.loRaEndNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[0].LoRaNodeApp.forcedDestinationId = 2000   # Send to rescue node ID 2001
**.loRaEndNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 1
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 1000s

# Common data-plane parameters
**.dataPacketDefaultSize = 11B
**.packetTTL = 20


# Simulation window
sim-time-limit = 800s
warmup-period = 0s

# =================================================================
# DSDV VARIANT: End node (ID 1000) sends to rescue node (ID 2000)
# Uses DSDV protocol with proactive updates (incremental + periodic full)
# Extends the existing EndNode1000_to_Rescue2000 scenario
# =================================================================
[Config EndNode1000_to_Rescue2000_DSDV]
extends = EndNode1000_to_Rescue2000

cmdenv-express-mode = false
# Also save logs to file when running in Qtenv
cmdenv-output-file = 50_nodes_DSDV.txt
cmdenv-redirect-output = true  # Enable file output even in Qtenv mode

# Enable INFO-level logging for DSDV debug messages in LoRaNodeApp
**.LoRaNodeApp.cmdenv-log-level = info
#**.LoRaNodeApp.qtenv-log-level = info


# Select DSDV protocol for ALL node types (legacy remains default elsewhere)
**.routingProtocol = "dsdv"
**.loRaNodes[*].LoRaNodeApp.routingProtocol = "dsdv"
**.loRaEndNodes[*].LoRaNodeApp.routingProtocol = "dsdv"
**.loRaRescueNodes[*].LoRaNodeApp.routingProtocol = "dsdv"

# DSDV timers and parameters (apply to all node types)
**.dsdvIncrementalPeriod = 15s
**.dsdvFullUpdatePeriod = 120s
**.dsdvTriggeredMinInterval = 3s
**.dsdvRouteLifetime = 2000s
**.dsdvTimerJitterMin = 0.2s
**.dsdvTimerJitterMax = 2s
**.dsdvNeighborTimeout = 40s
**.dsdvUseChunking = true
**.dsdvMaxEntriesPerPacket = 10

# Explicitly set DSDV parameters for relay router nodes
**.loRaNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 50s
**.loRaNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 200s
**.loRaNodes[*].LoRaNodeApp.dsdvTimerJitterMin = 0.2s
**.loRaNodes[*].LoRaNodeApp.dsdvTimerJitterMax = 2s

# Explicitly set DSDV parameters for end nodes
**.loRaEndNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 30s
**.loRaEndNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 140s
**.loRaEndNodes[*].LoRaNodeApp.dsdvTimerJitterMin = 0.2s
**.loRaEndNodes[*].LoRaNodeApp.dsdvTimerJitterMax = 2s

# Explicitly set DSDV parameters for rescue nodes
**.loRaRescueNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 15s
**.loRaRescueNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 120s
**.loRaRescueNodes[*].LoRaNodeApp.dsdvTimerJitterMin = 0.2s
**.loRaRescueNodes[*].LoRaNodeApp.dsdvTimerJitterMax = 2s

# ENABLE DSDV routing table freeze feature for ALL node types
# Freeze routing table once all nodes are learned, stop DSDV globally when all frozen
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false      # Legacy threshold not used for DSDV
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true   # ENABLE global stop
**.loRaEndNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false
**.loRaEndNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true
**.loRaRescueNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false
**.loRaRescueNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true

# DSDV freeze threshold (optional):
# If not set or set to -1, auto-calculates based on total nodes (numberOfNodes + numberOfEndNodes + numberOfRescueNodes - 1)
# For this config: 50 relay + 1 end + 1 rescue - 1 self = 51 unique destinations per node
# Set explicitly to 10 to test early freeze behavior
**.loRaNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = 20  # Explicit: freeze when table has 10 routes
**.loRaEndNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = 20
**.loRaRescueNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = 20

# Disable legacy routing beacon timers - DSDV has its own periodic timers
# Setting very high values effectively disables legacy beacons
**.loRaNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 1000000s
**.loRaEndNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 1000000s
**.loRaRescueNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 1000000s

# CRITICAL: ALL nodes use routingMetric=3 to participate in DSDV routing protocol
# This ensures end/rescue nodes send DSDV packets so relays learn routes TO them
# Data forwarding behavior is determined by node TYPE, not routingMetric:
#   - End/rescue nodes (isEndNodeHost/isRescueNodeHost): Always broadcast data packets
#   - Relay nodes: Use DSDV routing tables for unicast forwarding
# This matches legacy routing architecture (see DV_End1000_to_End1001 and EndNode1000_to_Rescue2000)
**.loRaNodes[*].LoRaNodeApp.routingMetric = 3       # Relay nodes use routing tables
**.loRaEndNodes[*].LoRaNodeApp.routingMetric = 3    # End nodes send DSDV packets, broadcast data
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 3 # Rescue nodes send DSDV packets, broadcast data

# Route discovery enabled for ALL nodes to participate in DSDV protocol
**.loRaNodes[*].LoRaNodeApp.routeDiscovery = true
**.loRaEndNodes[*].LoRaNodeApp.routeDiscovery = true
**.loRaRescueNodes[*].LoRaNodeApp.routeDiscovery = true

# Delay data transmission to allow DSDV routes to propagate first
# DSDV full updates occur at ~120s, so data should start after that
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 1000s

# =================================================================
# WELLINGTON MAP VARIANT: DSDV with 21 relay nodes (Wellington topology)
# Uses Wellington map and node positions from wellington_original.ini
# =================================================================
[Config EndNode1000_to_Rescue2000_DSDV_Wellington]
extends = EndNode1000_to_Rescue2000_DSDV

cmdenv-express-mode = false
# Also save logs to file when running in Qtenv
cmdenv-output-file = wellington_console_output.txt
cmdenv-redirect-output = true  # Enable file output even in Qtenv mode

# Enable INFO-level logging for DSDV debug messages in LoRaNodeApp
**.LoRaNodeApp.cmdenv-log-level = info
#**.LoRaNodeApp.qtenv-log-level = info

# Wellington map and area
LoRaMesh.mapPath = "map/wellington"
LoRaMesh.mapWidth = 9824  # Wellington map dimensions
LoRaMesh.mapHeight = 9824
**.constraintAreaMaxX = 10000m
**.constraintAreaMaxY = 10000m

# 20 relay nodes instead of 50
**.numberOfNodes = 20

# Reduce transmit power for Wellington scenario to limit range
**.loRaNodes[*].**initialLoRaTP = 17dBm
**.loRaRescueNodes[*].**initialLoRaTP = 17dBm

# Override grid deployment - use manual positioning instead
**.loRaNodes[*].deploymentType = "manual"

# Wellington relay node positions (21 nodes)
**.loRaNodes[0].initialX = 5000m
**.loRaNodes[0].initialY = 5000m

**.loRaNodes[1].initialX = 0m
**.loRaNodes[1].initialY = 2120m

**.loRaNodes[2].initialX = 0m
**.loRaNodes[2].initialY = 4090m

**.loRaNodes[3].initialX = 0m
**.loRaNodes[3].initialY = 6050m

**.loRaNodes[4].initialX = 0m
**.loRaNodes[4].initialY = 8070m

**.loRaNodes[5].initialX = 2110m
**.loRaNodes[5].initialY = 0m

**.loRaNodes[6].initialX = 2070m
**.loRaNodes[6].initialY = 2050m

**.loRaNodes[7].initialX = 2100m
**.loRaNodes[7].initialY = 4050m

**.loRaNodes[8].initialX = 2010m
**.loRaNodes[8].initialY = 6100m

**.loRaNodes[9].initialX = 2240m
**.loRaNodes[9].initialY = 8010m

**.loRaNodes[10].initialX = 4080m
**.loRaNodes[10].initialY = 0m

**.loRaNodes[11].initialX = 4100m
**.loRaNodes[11].initialY = 2090m

**.loRaNodes[12].initialX = 4050m
**.loRaNodes[12].initialY = 4100m

**.loRaNodes[13].initialX = 4020m
**.loRaNodes[13].initialY = 6030m

**.loRaNodes[14].initialX = 4070m
**.loRaNodes[14].initialY = 8110m

**.loRaNodes[15].initialX = 6100m
**.loRaNodes[15].initialY = 4070m

**.loRaNodes[16].initialX = 6040m
**.loRaNodes[16].initialY = 6090m

**.loRaNodes[17].initialX = 6050m
**.loRaNodes[17].initialY = 8040m

**.loRaNodes[18].initialX = 8100m
**.loRaNodes[18].initialY = 4070m

**.loRaNodes[19].initialX = 8040m
**.loRaNodes[19].initialY = 6080m

# Override parent config's large circle deployment for end nodes
# Parent has centX=10000, centY=10000, rad=9000 which exceeds Wellington constraint area
**.loRaEndNodes[*].deploymentType = "circle"
**.loRaEndNodes[*].rad = 4000
**.loRaEndNodes[*].centX = 5000
**.loRaEndNodes[*].centY = 5000

# Explicitly set constraint area for end nodes to match Wellington boundaries
**.loRaEndNodes[*].mobility.constraintAreaMinX = 0m
**.loRaEndNodes[*].mobility.constraintAreaMinY = 0m
**.loRaEndNodes[*].mobility.constraintAreaMaxX = 10000m
**.loRaEndNodes[*].mobility.constraintAreaMaxY = 10000m

# Switch rescue node to TurtleMobility (scripted waypoint movement)
**.loRaRescueNodes[*].mobilityType = "TurtleMobility"

# Turtle script file: custom patrol pattern at 5 m/s
**.loRaRescueNodes[*].mobility.turtleScript = xmldoc("turtle_patrol_5mps_200s.xml")

# Ensure deploymentType does not override initial position
# (disable circle/random deployment so mobility.initialX/Y are used)
**.loRaRescueNodes[*].deploymentType = ""

# Starting position for the patrol (center of Wellington area)
**.loRaRescueNodes[0].mobility.initialX = 5000m
**.loRaRescueNodes[0].mobility.initialY = 5000m

# Constraint area (match Wellington boundaries)
**.loRaRescueNodes[*].mobility.constraintAreaMinX = 0m
**.loRaRescueNodes[*].mobility.constraintAreaMinY = 0m
**.loRaRescueNodes[*].mobility.constraintAreaMaxX = 10000m
**.loRaRescueNodes[*].mobility.constraintAreaMaxY = 10000m

# Position update interval (smoother movement visualization)
**.loRaRescueNodes[*].mobility.updateInterval = 0.1s

# Disable display-string position initialization
**.loRaRescueNodes[*].**.initFromDisplayString = false


# DSDV timer periods - rescue nodes update more frequently than relay/end nodes
# Relay nodes (default/slower updates)
**.loRaNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 110s
**.loRaNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 200s

# End nodes (default/slower updates)
**.loRaEndNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 30s
**.loRaEndNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 120s

# Rescue nodes (faster updates due to mobility)
**.loRaRescueNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 15s   # Update every 8s (faster than relay nodes)
**.loRaRescueNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 120s   # Full dump every 60s (twice as fast)

# Adjust neighbor cache for Wellington area
**.LoRaMedium.neighborCache.range = 3000m  # Same as wellington_original

# Update routing freeze threshold for 21 nodes (instead of 50)
# Each node should learn routes to: 20 other relays + 1 end (1000) + 1 rescue (2000) = 22 total
#**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 22
# Simulation window
sim-time-limit = 1200s
warmup-period = 0s

# =================================================================
# SMART FLOODING VARIANT: End node (ID 1000) sends to rescue node (ID 2000)
# Uses SMART_BROADCAST for relay nodes (routing metric 2)
# End and rescue nodes broadcast to nearest neighbors (routing metric 1)
# Based on Wellington topology with mobile rescue node
# =================================================================
[Config EndNode1000_to_Rescue2000_SmartFlooding_Wellington]
extends = EndNode1000_to_Rescue2000

cmdenv-express-mode = false
cmdenv-output-file = wellington_smartflooding_output.txt
cmdenv-redirect-output = true

# Enable INFO-level logging
**.LoRaNodeApp.cmdenv-log-level = info

# Wellington map and area
LoRaMesh.mapPath = "map/wellington"
LoRaMesh.mapWidth = 9824
LoRaMesh.mapHeight = 9824
**.constraintAreaMaxX = 10000m
**.constraintAreaMaxY = 10000m

# 20 relay nodes instead of 50
**.numberOfNodes = 20

# Override grid deployment - use manual positioning
**.loRaNodes[*].deploymentType = "manual"

# Wellington relay node positions (21 nodes)
**.loRaNodes[0].initialX = 5000m
**.loRaNodes[0].initialY = 5000m

**.loRaNodes[1].initialX = 0m
**.loRaNodes[1].initialY = 2120m

**.loRaNodes[2].initialX = 0m
**.loRaNodes[2].initialY = 4090m

**.loRaNodes[3].initialX = 0m
**.loRaNodes[3].initialY = 6050m

**.loRaNodes[4].initialX = 0m
**.loRaNodes[4].initialY = 8070m

**.loRaNodes[5].initialX = 2110m
**.loRaNodes[5].initialY = 0m

**.loRaNodes[6].initialX = 2070m
**.loRaNodes[6].initialY = 2050m

**.loRaNodes[7].initialX = 2100m
**.loRaNodes[7].initialY = 4050m

**.loRaNodes[8].initialX = 2010m
**.loRaNodes[8].initialY = 6100m

**.loRaNodes[9].initialX = 2240m
**.loRaNodes[9].initialY = 8010m

**.loRaNodes[10].initialX = 4080m
**.loRaNodes[10].initialY = 0m

**.loRaNodes[11].initialX = 4100m
**.loRaNodes[11].initialY = 2090m

**.loRaNodes[12].initialX = 4050m
**.loRaNodes[12].initialY = 4100m

**.loRaNodes[13].initialX = 4020m
**.loRaNodes[13].initialY = 6030m

**.loRaNodes[14].initialX = 4070m
**.loRaNodes[14].initialY = 8110m

**.loRaNodes[15].initialX = 6100m
**.loRaNodes[15].initialY = 4070m

**.loRaNodes[16].initialX = 6040m
**.loRaNodes[16].initialY = 6090m

**.loRaNodes[17].initialX = 6050m
**.loRaNodes[17].initialY = 8040m

**.loRaNodes[18].initialX = 8100m
**.loRaNodes[18].initialY = 4070m

**.loRaNodes[19].initialX = 8040m
**.loRaNodes[19].initialY = 6080m

# Adjust placement for Wellington area
# End nodes (1 node, ID 1000) and Rescue nodes (1 node, ID 2000) use circle deployment
**.loRaEndNodes[*].deploymentType = "circle"
**.loRaEndNodes[*].rad = 4000
**.loRaEndNodes[*].centX = 5000
**.loRaEndNodes[*].centY = 5000

**.loRaRescueNodes[*].deploymentType = "circle"
**.loRaRescueNodes[*].rad = 3500
**.loRaRescueNodes[*].centX = 4000
**.loRaRescueNodes[*].centY = 4000

# MassMobility parameters for rescue nodes (same as DSDV variant)
**.loRaRescueNodes[*].mobility.changeInterval = truncnormal(2s, 0.5s)
**.loRaRescueNodes[*].mobility.changeAngleBy = normal(0deg, 30deg)
**.loRaRescueNodes[0].mobility.speed = 5mps

# SMART FLOODING CONFIGURATION
# Disable routing discovery - no routing beacons needed for flooding
**.routeDiscovery = false
**.loRaNodes[*].LoRaNodeApp.routeDiscovery = false
**.loRaEndNodes[*].LoRaNodeApp.routeDiscovery = false
**.loRaRescueNodes[*].LoRaNodeApp.routeDiscovery = false

# Disable routing protocol selection (use default legacy behavior)
**.routingProtocol = "legacy"

# Set routing metrics:
# - Relay nodes: SMART_BROADCAST_SINGLE_SF (routing metric 2)
# - End/Rescue nodes: FLOODING/BROADCAST (routing metric 1)
**.loRaNodes[*].LoRaNodeApp.routingMetric = 2      # Smart flooding for relays
**.loRaEndNodes[*].LoRaNodeApp.routingMetric = 1   # Broadcast for end nodes
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 1 # Broadcast for rescue nodes

# Disable convergence features (not applicable for flooding)
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false

# Disable legacy routing beacon timers
**.loRaNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 1000000s
**.loRaEndNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 1000000s
**.loRaRescueNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 1000000s

# Data transmission: end node sends one packet to rescue node
# Start data transmission earlier since no routing convergence needed
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 60s

# Adjust neighbor cache for Wellington area
**.LoRaMedium.neighborCache.range = 3000m

# Reduce transmit power for Wellington scenario to limit range
**.loRaNodes[*].**initialLoRaTP = 17dBm
**.loRaRescueNodes[*].**initialLoRaTP = 17dBm

# Simulation window
sim-time-limit = 800s
warmup-period = 0s

# Recording
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true

# =================================================================
# WELLINGTON GRID VARIANT: DSDV with 20 relay nodes in 2.5km grid
# EXTENDS Wellington variant to inherit proper node counts and settings
# =================================================================
[Config EndNode1000_to_Rescue2000_DSDV_Wellington_Grid2km]
extends = EndNode1000_to_Rescue2000_DSDV_Wellington

cmdenv-express-mode = false
# Also save logs to file when running in Qtenv
cmdenv-output-file = wellington_grid2km_console_output.txt
cmdenv-redirect-output = true  # Enable file output even in Qtenv mode

# Enable INFO-level logging for DSDV debug messages in LoRaNodeApp
**.LoRaNodeApp.cmdenv-log-level = info

# Wellington map and area
LoRaMesh.mapPath = "map/wellington"
LoRaMesh.mapWidth = 9824  # Wellington map dimensions
LoRaMesh.mapHeight = 9824
**.constraintAreaMaxX = 10000m
**.constraintAreaMaxY = 10000m

# 20 relay nodes instead of 50
**.numberOfNodes = 20

# DSDV Freeze Configuration:
# Auto-freeze threshold: 20 relay + 1 end + 1 rescue - self = 21 unique destinations
# Explicit threshold is set at the bottom of this config (currently 10)
# Change the value there to control when routing tables freeze

# Transmit power for Wellington scenario - 17dBm ensures full connectivity in 2.5km grid
**.loRaNodes[*].**initialLoRaTP = 17dBm
**.loRaRescueNodes[*].**initialLoRaTP = 17dBm
**.loRaEndNodes[*].**initialLoRaTP = 17dBm

# Override grid deployment - use manual positioning for 2000m grid
**.loRaNodes[*].deploymentType = "manual"

# 20 nodes in 5x4 grid, 2500m spacing
# Grid columns (x): 0, 2500, 5000, 7500, 10000
# Grid rows (y): 1250, 3750, 6250, 8750
# Row 0 (y=1250m): nodes 0-4
**.loRaNodes[0].initialX = 0m
**.loRaNodes[0].initialY = 1250m

**.loRaNodes[1].initialX = 2500m
**.loRaNodes[1].initialY = 1250m

**.loRaNodes[2].initialX = 5000m
**.loRaNodes[2].initialY = 1250m

**.loRaNodes[3].initialX = 7500m
**.loRaNodes[3].initialY = 1250m

**.loRaNodes[4].initialX = 10000m
**.loRaNodes[4].initialY = 1250m

# Row 1 (y=3750m): nodes 5-9
**.loRaNodes[5].initialX = 0m
**.loRaNodes[5].initialY = 3750m

**.loRaNodes[6].initialX = 2500m
**.loRaNodes[6].initialY = 3750m

**.loRaNodes[7].initialX = 5000m
**.loRaNodes[7].initialY = 3750m

**.loRaNodes[8].initialX = 7500m
**.loRaNodes[8].initialY = 3750m

**.loRaNodes[9].initialX = 10000m
**.loRaNodes[9].initialY = 3750m

# Row 2 (y=6250m): nodes 10-14
**.loRaNodes[10].initialX = 0m
**.loRaNodes[10].initialY = 6250m

**.loRaNodes[11].initialX = 2500m
**.loRaNodes[11].initialY = 6250m

**.loRaNodes[12].initialX = 5000m
**.loRaNodes[12].initialY = 6250m

**.loRaNodes[13].initialX = 7500m
**.loRaNodes[13].initialY = 6250m

**.loRaNodes[14].initialX = 10000m
**.loRaNodes[14].initialY = 6250m

# Row 3 (y=8750m): nodes 15-19
**.loRaNodes[15].initialX = 0m
**.loRaNodes[15].initialY = 8750m

**.loRaNodes[16].initialX = 2500m
**.loRaNodes[16].initialY = 8750m

**.loRaNodes[17].initialX = 5000m
**.loRaNodes[17].initialY = 8750m

**.loRaNodes[18].initialX = 7500m
**.loRaNodes[18].initialY = 8750m

**.loRaNodes[19].initialX = 10000m
**.loRaNodes[19].initialY = 8750m

# Override parent config's large circle deployment for end nodes
# Parent has centX=10000, centY=10000, rad=9000 which exceeds Wellington constraint area
**.loRaEndNodes[*].deploymentType = "circle"
**.loRaEndNodes[*].rad = 4000
**.loRaEndNodes[*].centX = 5000
**.loRaEndNodes[*].centY = 5000

# Explicitly set constraint area for end nodes to match Wellington boundaries
**.loRaEndNodes[*].mobility.constraintAreaMinX = 0m
**.loRaEndNodes[*].mobility.constraintAreaMinY = 0m
**.loRaEndNodes[*].mobility.constraintAreaMaxX = 10000m
**.loRaEndNodes[*].mobility.constraintAreaMaxY = 10000m

# Switch rescue node to TurtleMobility (scripted waypoint movement)
**.loRaRescueNodes[*].mobilityType = "TurtleMobility"

# Turtle script file: 2km square patrol pattern at 10 m/s
**.loRaRescueNodes[*].mobility.turtleScript = xmldoc("turtle_stationary_0mps.xml")

# Ensure deploymentType does not override initial position
# (disable circle/random deployment so mobility.initialX/Y are used)
**.loRaRescueNodes[*].deploymentType = ""

# Starting position for the patrol (center of Wellington area)
**.loRaRescueNodes[0].mobility.initialX = 5000m
**.loRaRescueNodes[0].mobility.initialY = 5000m

# Constraint area (match Wellington boundaries)
**.loRaRescueNodes[*].mobility.constraintAreaMinX = 0m
**.loRaRescueNodes[*].mobility.constraintAreaMinY = 0m
**.loRaRescueNodes[*].mobility.constraintAreaMaxX = 10000m
**.loRaRescueNodes[*].mobility.constraintAreaMaxY = 10000m

# Position update interval (smoother movement visualization)
**.loRaRescueNodes[*].mobility.updateInterval = 0.1s

# Disable display-string position initialization
**.loRaRescueNodes[*].**.initFromDisplayString = false

# DATA TRANSMISSION: End node (1000) sends 10 packets to rescue node (2000) using DSDV
**.loRaEndNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 10
# End node sends exactly one packet to the rescue node (ID 2000)
**.loRaEndNodes[0].LoRaNodeApp.sendPacketsContinuously = false
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 100s   # Send every 10-15 seconds  
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 110s


# DSDV timer periods - rescue nodes update more frequently than relay/end nodes
# Relay nodes (default/slower updates)
**.loRaNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 110s
**.loRaNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 200s

# End nodes (default/slower updates)
**.loRaEndNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 30s
**.loRaEndNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 120s

# Rescue nodes (faster updates due to mobility)
**.loRaRescueNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 15s   # Update every 15s (faster than relay nodes)
**.loRaRescueNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 120s   # Full dump every 120s

# Adjust neighbor cache for Wellington area
**.LoRaMedium.neighborCache.range = 3000m

**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false
**.loRaEndNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false
**.loRaRescueNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false



# =================================================================
# EXPLICIT FREEZE THRESHOLD - Change this value to control when routing tables freeze
# Set to -1 to disable unique-count-based freezing completely
# Example: 10 = freeze when 10 unique destinations learned
#          21 = freeze when all 22 nodes are known (20 relay + 1 end + 1 rescue)
#          -1 = disable threshold-based freezing (default)
# =================================================================

# DSDV-specific freeze threshold (used when routingProtocol = "dsdv")
**.loRaNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = -1  # Disable DSDV unique count freeze
**.loRaEndNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = -1
**.loRaRescueNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = -1

# Legacy freeze parameters (must also be disabled to prevent parent config values from triggering freeze)
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false      # Disable legacy freeze feature
**.loRaEndNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false
**.loRaRescueNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false

**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = -1       # Override parent config's threshold=3
**.loRaEndNodes[*].LoRaNodeApp.routingFreezeUniqueCount = -1
**.loRaRescueNodes[*].LoRaNodeApp.routingFreezeUniqueCount = -1

# Simulation window
sim-time-limit = 1200s
warmup-period = 0s

# =================================================================
# FILTERED DESTINATIONS VARIANT: Only store/advertise routes to end/rescue nodes
# Extends Wellington Grid2km to add destination filtering
# Relays (ID 0-999): Do not appear as destinations in routing tables
# End nodes (ID 1000+): Appear as destinations
# Rescue nodes (ID 2000+): Appear as destinations
# Expected routing table size per node: 2 entries (nodes 1000 and 2000)
# =================================================================
[Config EndNode1000_to_Rescue2000_DSDV_Wellington_Grid2km_FilteredDestinations]
extends = EndNode1000_to_Rescue2000_DSDV_Wellington_Grid2km

# Enable destination filtering for all node types
# When enabled, nodes will:
# 1. NOT store routing entries where destination is a relay router (ID < 1000)
# 2. NOT advertise routing entries for relay routers in DSDV updates
# 3. Only propagate routes to end nodes (ID >= 1000) and rescue nodes (ID >= 2000)
# Relay nodes still participate in routing (send DSDV packets, forward data), they just don't appear as destinations

**.loRaNodes[*].LoRaNodeApp.dsdvFilterRelayDestinations = true
**.loRaEndNodes[*].LoRaNodeApp.dsdvFilterRelayDestinations = true
**.loRaRescueNodes[*].LoRaNodeApp.dsdvFilterRelayDestinations = true

# Logging output specific to this filtered variant
cmdenv-output-file = wellington_grid2km_filtered_console_output.txt
# DSDV timer periods - rescue nodes update more frequently than relay/end nodes
# Relay nodes (default/slower updates)
**.loRaNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 200s
**.loRaNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 250s

# End nodes (default/slower updates)
**.loRaEndNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 30s
**.loRaEndNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 120s

# Rescue nodes (faster updates due to mobility)
**.loRaRescueNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 15s   # Update every 8s (faster than relay nodes)
**.loRaRescueNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 120s   # Full dump every 60s (twice as fast)


##FOR CONTROLLING ROUTE FREEZING

**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false
**.loRaEndNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false
**.loRaRescueNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false

# DSDV-specific freeze threshold (used when routingProtocol = "dsdv")
**.loRaNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = -1  # Disable DSDV unique count freeze
**.loRaEndNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = -1
**.loRaRescueNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = -1

# Legacy freeze parameters (must also be disabled to prevent parent config values from triggering freeze)
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false      # Disable legacy freeze feature
**.loRaEndNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false
**.loRaRescueNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false

**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 3       # Override parent config's threshold=3
**.loRaEndNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 3
**.loRaRescueNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 3

# Override rescue node mobility: start at top left corner and patrol a 7000m square
# Starting position: top left corner of the patrol square (1500m, 8500m)
# Square patrol pattern: 
#   - Start: top left (1500m, 8500m)
#   - Move 7000m East → top right (8500m, 8500m)
#   - Turn right, move 7000m South → bottom right (8500m, 1500m)
#   - Turn right, move 7000m West → bottom left (1500m, 1500m)
#   - Turn right, move 7000m North → back to top left (1500m, 8500m)

# CRITICAL: Explicitly set TurtleMobility (overrides parent's MassMobility)
**.loRaRescueNodes[*].mobilityType = "TurtleMobility"

# CRITICAL: Disable automatic deployment so mobility.initialX/Y are used
**.loRaRescueNodes[*].deploymentType = ""

# CRITICAL: Disable display string initialization
**.loRaRescueNodes[*].**.initFromDisplayString = false

# CRITICAL: Override parent config's RANDOM initial position with FIXED position
# Parent config uses uniform() random functions which change every run
# Must override BOTH the wildcard [*] pattern AND specific [0] pattern
**.loRaRescueNodes[*].mobility.initialX = 1500m
**.loRaRescueNodes[*].mobility.initialY = 8500m
**.loRaRescueNodes[0].mobility.initialX = 1500m
**.loRaRescueNodes[0].mobility.initialY = 8500m

# Constraint area (match Wellington Grid2km boundaries)
**.loRaRescueNodes[*].mobility.constraintAreaMinX = 0m
**.loRaRescueNodes[*].mobility.constraintAreaMinY = 0m
**.loRaRescueNodes[*].mobility.constraintAreaMaxX = 10000m
**.loRaRescueNodes[*].mobility.constraintAreaMaxY = 10000m

# Use mobile turtle script instead of stationary (choose speed: 5mps, 7mps, 8mps, or 11mps)
**.loRaRescueNodes[*].mobility.turtleScript = xmldoc("turtle_patrol_11mps_2km.xml")


# DUTY-CYCLE OVERRIDE FOR THIS CONFIG
# Global General section sets **.dutyCycle = 0.01 and **.enforceDutyCycle = ${enforceDutyCycle = true, false}
# That heavily throttles application traffic when DSDV + routing packets are frequent.
# For this experiment we want the end node to be able to send all 100 data packets
# with ~50s spacing, so we disable duty-cycle enforcement here.
**.dutyCycle = 1.0
**.enforceDutyCycle = false


# DATA TRANSMISSION: End node (1000) sends 100 packets to rescue node (2000) using DSDV
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 1000s
**.loRaEndNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 100
# End node sends exactly 100 packets to the rescue node (ID 2000)
**.loRaEndNodes[0].LoRaNodeApp.sendPacketsContinuously = false
# Packet interval: send every 45-55 seconds (100 packets * 50s avg = 5000s + 1000s first = 6000s total)
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketMin = 45s
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 55s
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 50s


# Simulation window - Extended to 6500s to allow all 100 packets with 50s intervals
# Calculation: 1000s (first packet) + 99 intervals * 50s avg = 1000s + 4950s = 5950s + 550s buffer
sim-time-limit = 6500s
warmup-period = 0s


# =================================================================
# FILTERED DESTINATIONS - 4 END NODES VARIANT
# Extends FilteredDestinations config with 4 end nodes sending packets simultaneously
# Each end node sends 20 packets to the rescue node (total 80 packets)
# =================================================================
[Config Four_EndNodes_to_Rescue2000_DSDV_Wellington_Grid2km_FilteredDestinations]
extends = EndNode1000_to_Rescue2000_DSDV_Wellington_Grid2km_FilteredDestinations

# Override output file for this variant
cmdenv-output-file = wellington_grid2km_filtered_4endnodes_console_output.txt

# Change number of end nodes from 1 to 4
**.numberOfEndNodes = 4

# DISABLE routing table freezing and convergence detection
# (Parent config has these enabled, but we want continuous routing updates)
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false
**.loRaEndNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false
**.loRaRescueNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false

# Disable DSDV freeze threshold (-1 = completely disabled)
**.loRaNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = -1
**.loRaEndNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = -1
**.loRaRescueNodes[*].LoRaNodeApp.dsdvFreezeUniqueCount = -1

# Use mobile turtle script instead of stationary (choose speed: 5mps, 7mps, 8mps, or 11mps)
**.loRaRescueNodes[*].mobility.turtleScript = xmldoc("turtle_patrol_11mps_2km.xml")


# End nodes deployment - use circle deployment for random positioning
# (This is already set in parent config, but explicitly confirming here)
**.loRaEndNodes[*].deploymentType = "circle"
**.loRaEndNodes[*].rad = 4000
**.loRaEndNodes[*].centX = 5000
**.loRaEndNodes[*].centY = 5000

# Explicitly set constraint area for end nodes to match Wellington boundaries
**.loRaEndNodes[*].mobility.constraintAreaMinX = 0m
**.loRaEndNodes[*].mobility.constraintAreaMinY = 0m
**.loRaEndNodes[*].mobility.constraintAreaMaxX = 10000m
**.loRaEndNodes[*].mobility.constraintAreaMaxY = 10000m

# DATA TRANSMISSION: All 4 end nodes (1000-1003) send 20 packets each to rescue node (2000)
# End node 0 (ID 1000)
**.loRaEndNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[0].LoRaNodeApp.forcedDestinationId = 2000
**.loRaEndNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 1000s
**.loRaEndNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 20
**.loRaEndNodes[0].LoRaNodeApp.sendPacketsContinuously = false
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketMin = 45s
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 55s
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 50s

# End node 1 (ID 1001)
**.loRaEndNodes[1].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[1].LoRaNodeApp.forcedDestinationId = 2000
**.loRaEndNodes[1].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[1].LoRaNodeApp.timeToFirstDataPacket = 1000s
**.loRaEndNodes[1].LoRaNodeApp.numberOfPacketsPerDestination = 20
**.loRaEndNodes[1].LoRaNodeApp.sendPacketsContinuously = false
**.loRaEndNodes[1].LoRaNodeApp.timeToNextDataPacketMin = 45s
**.loRaEndNodes[1].LoRaNodeApp.timeToNextDataPacketMax = 55s
**.loRaEndNodes[1].LoRaNodeApp.timeToNextDataPacketAvg = 50s

# End node 2 (ID 1002)
**.loRaEndNodes[2].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[2].LoRaNodeApp.forcedDestinationId = 2000
**.loRaEndNodes[2].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[2].LoRaNodeApp.timeToFirstDataPacket = 1000s
**.loRaEndNodes[2].LoRaNodeApp.numberOfPacketsPerDestination = 20
**.loRaEndNodes[2].LoRaNodeApp.sendPacketsContinuously = false
**.loRaEndNodes[2].LoRaNodeApp.timeToNextDataPacketMin = 45s
**.loRaEndNodes[2].LoRaNodeApp.timeToNextDataPacketMax = 55s
**.loRaEndNodes[2].LoRaNodeApp.timeToNextDataPacketAvg = 50s

# End node 3 (ID 1003)
**.loRaEndNodes[3].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[3].LoRaNodeApp.forcedDestinationId = 2000
**.loRaEndNodes[3].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[3].LoRaNodeApp.timeToFirstDataPacket = 1000s
**.loRaEndNodes[3].LoRaNodeApp.numberOfPacketsPerDestination = 20
**.loRaEndNodes[3].LoRaNodeApp.sendPacketsContinuously = false
**.loRaEndNodes[3].LoRaNodeApp.timeToNextDataPacketMin = 45s
**.loRaEndNodes[3].LoRaNodeApp.timeToNextDataPacketMax = 55s
**.loRaEndNodes[3].LoRaNodeApp.timeToNextDataPacketAvg = 50s

# Simulation window - Same as parent config
# With 20 packets per node at 50s avg interval: 1000s + 19*50s = 1950s per node
# All nodes transmit concurrently, so total time is still ~2000s + routing overhead
# Keep parent's 6500s limit for safety
sim-time-limit = 6500s
warmup-period = 0s


# =================================================================
# SMART FLOODING GRID2KM VARIANT: 20 relay nodes in 2.5km grid with 100 packets
# Extends SmartFlooding Wellington to use same grid layout as DSDV variant
# End node sends 100 packets to rescue node using Smart Flooding routing
# =================================================================
[Config EndNode1000_to_Rescue2000_SmartFlooding_Wellington_Grid2km]
extends = EndNode1000_to_Rescue2000_SmartFlooding_Wellington

cmdenv-express-mode = false
cmdenv-output-file = wellington_grid2km_smartflooding_console_output.txt
cmdenv-redirect-output = true

# Wellington map and area
LoRaMesh.mapPath = "map/wellington"
LoRaMesh.mapWidth = 9824
LoRaMesh.mapHeight = 9824
**.constraintAreaMaxX = 10000m
**.constraintAreaMaxY = 10000m

# 20 relay nodes in 2.5km grid (same as DSDV variant)
**.numberOfNodes = 20

# Transmit power for Wellington scenario - 17dBm ensures full connectivity in 2.5km grid
**.loRaNodes[*].**initialLoRaTP = 17dBm
**.loRaRescueNodes[*].**initialLoRaTP = 17dBm
**.loRaEndNodes[*].**initialLoRaTP = 17dBm

# Override grid deployment - use manual positioning for 2000m grid
**.loRaNodes[*].deploymentType = "manual"

# 20 nodes in 5x4 grid, 2500m spacing
# Grid columns (x): 0, 2500, 5000, 7500, 10000
# Grid rows (y): 1250, 3750, 6250, 8750
# Row 0 (y=1250m): nodes 0-4
**.loRaNodes[0].initialX = 0m
**.loRaNodes[0].initialY = 1250m

**.loRaNodes[1].initialX = 2500m
**.loRaNodes[1].initialY = 1250m

**.loRaNodes[2].initialX = 5000m
**.loRaNodes[2].initialY = 1250m

**.loRaNodes[3].initialX = 7500m
**.loRaNodes[3].initialY = 1250m

**.loRaNodes[4].initialX = 10000m
**.loRaNodes[4].initialY = 1250m

# Row 1 (y=3750m): nodes 5-9
**.loRaNodes[5].initialX = 0m
**.loRaNodes[5].initialY = 3750m

**.loRaNodes[6].initialX = 2500m
**.loRaNodes[6].initialY = 3750m

**.loRaNodes[7].initialX = 5000m
**.loRaNodes[7].initialY = 3750m

**.loRaNodes[8].initialX = 7500m
**.loRaNodes[8].initialY = 3750m

**.loRaNodes[9].initialX = 10000m
**.loRaNodes[9].initialY = 3750m

# Row 2 (y=6250m): nodes 10-14
**.loRaNodes[10].initialX = 0m
**.loRaNodes[10].initialY = 6250m

**.loRaNodes[11].initialX = 2500m
**.loRaNodes[11].initialY = 6250m

**.loRaNodes[12].initialX = 5000m
**.loRaNodes[12].initialY = 6250m

**.loRaNodes[13].initialX = 7500m
**.loRaNodes[13].initialY = 6250m

**.loRaNodes[14].initialX = 10000m
**.loRaNodes[14].initialY = 6250m

# Row 3 (y=8750m): nodes 15-19
**.loRaNodes[15].initialX = 0m
**.loRaNodes[15].initialY = 8750m

**.loRaNodes[16].initialX = 2500m
**.loRaNodes[16].initialY = 8750m

**.loRaNodes[17].initialX = 5000m
**.loRaNodes[17].initialY = 8750m

**.loRaNodes[18].initialX = 7500m
**.loRaNodes[18].initialY = 8750m

**.loRaNodes[19].initialX = 10000m
**.loRaNodes[19].initialY = 8750m

# Override parent config's large circle deployment for end nodes
**.loRaEndNodes[*].deploymentType = "circle"
**.loRaEndNodes[*].rad = 4000
**.loRaEndNodes[*].centX = 5000
**.loRaEndNodes[*].centY = 5000

# Explicitly set constraint area for end nodes to match Wellington boundaries
**.loRaEndNodes[*].mobility.constraintAreaMinX = 0m
**.loRaEndNodes[*].mobility.constraintAreaMinY = 0m
**.loRaEndNodes[*].mobility.constraintAreaMaxX = 10000m
**.loRaEndNodes[*].mobility.constraintAreaMaxY = 10000m

# Switch rescue node to TurtleMobility (scripted waypoint movement)
**.loRaRescueNodes[*].mobilityType = "TurtleMobility"

# Turtle script file: stationary at center (can be changed to mobile patrol)
**.loRaRescueNodes[*].mobility.turtleScript = xmldoc("turtle_patrol_7mps_2km.xml")

# Ensure deploymentType does not override initial position
# (disable circle/random deployment so mobility.initialX/Y are used)
**.loRaRescueNodes[*].deploymentType = ""

# Starting position for the patrol (center of Wellington area)
**.loRaRescueNodes[0].mobility.initialX = 5000m
**.loRaRescueNodes[0].mobility.initialY = 5000m

# Constraint area (match Wellington boundaries)
**.loRaRescueNodes[*].mobility.constraintAreaMinX = 0m
**.loRaRescueNodes[*].mobility.constraintAreaMinY = 0m
**.loRaRescueNodes[*].mobility.constraintAreaMaxX = 10000m
**.loRaRescueNodes[*].mobility.constraintAreaMaxY = 10000m

# Position update interval (smoother movement visualization)
**.loRaRescueNodes[*].mobility.updateInterval = 0.1s

# Disable display-string position initialization
**.loRaRescueNodes[*].**.initFromDisplayString = false

# DATA TRANSMISSION: End node (1000) sends 100 packets to rescue node (2000) using Smart Flooding
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 1000s
**.loRaEndNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 100
**.loRaEndNodes[0].LoRaNodeApp.sendPacketsContinuously = false

# Packet interval: send every 45-55 seconds (100 packets * 50s avg = 5000s + 1000s first = 6000s total)
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketMin = 45s
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 55s
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 50s

# DUTY-CYCLE OVERRIDE FOR THIS CONFIG
# For flooding with 100 data packets, disable duty-cycle enforcement
# to ensure all packets can be transmitted without throttling
**.dutyCycle = 1.0
**.enforceDutyCycle = false

# Adjust neighbor cache for Wellington area
**.LoRaMedium.neighborCache.range = 3000m

# Simulation window - Extended to 6500s to allow all 100 packets with 50s intervals
# Calculation: 1000s (first packet) + 99 intervals * 50s avg = 1000s + 4950s = 5950s + 550s buffer
sim-time-limit = 6500s
warmup-period = 0s


# =================================================================
# SMART FLOODING - 4 END NODES VARIANT
# Extends SmartFlooding Grid2km config with 4 end nodes sending packets simultaneously
# Each end node sends 20 packets to the rescue node (total 80 packets)
# =================================================================
[Config Four_EndNodes_to_Rescue2000_SmartFlooding_Wellington_Grid2km]
extends = EndNode1000_to_Rescue2000_SmartFlooding_Wellington_Grid2km

# Override output file for this variant
cmdenv-output-file = wellington_grid2km_smartflooding_4endnodes_console_output.txt

# Change number of end nodes from 1 to 4
**.numberOfEndNodes = 4

# End nodes deployment - use circle deployment for random positioning
# (This is already set in parent config, but explicitly confirming here)
**.loRaEndNodes[*].deploymentType = "circle"
**.loRaEndNodes[*].rad = 4000
**.loRaEndNodes[*].centX = 5000
**.loRaEndNodes[*].centY = 5000

# Explicitly set constraint area for end nodes to match Wellington boundaries
**.loRaEndNodes[*].mobility.constraintAreaMinX = 0m
**.loRaEndNodes[*].mobility.constraintAreaMinY = 0m
**.loRaEndNodes[*].mobility.constraintAreaMaxX = 10000m
**.loRaEndNodes[*].mobility.constraintAreaMaxY = 10000m

# DATA TRANSMISSION: All 4 end nodes (1000-1003) send 20 packets each to rescue node (2000)
# End node 0 (ID 1000)
**.loRaEndNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[0].LoRaNodeApp.forcedDestinationId = 2000
**.loRaEndNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 60s
**.loRaEndNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 20
**.loRaEndNodes[0].LoRaNodeApp.sendPacketsContinuously = false
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketMin = 45s
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 55s
**.loRaEndNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 50s

# End node 1 (ID 1001)
**.loRaEndNodes[1].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[1].LoRaNodeApp.forcedDestinationId = 2000
**.loRaEndNodes[1].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[1].LoRaNodeApp.timeToFirstDataPacket = 60s
**.loRaEndNodes[1].LoRaNodeApp.numberOfPacketsPerDestination = 20
**.loRaEndNodes[1].LoRaNodeApp.sendPacketsContinuously = false
**.loRaEndNodes[1].LoRaNodeApp.timeToNextDataPacketMin = 45s
**.loRaEndNodes[1].LoRaNodeApp.timeToNextDataPacketMax = 55s
**.loRaEndNodes[1].LoRaNodeApp.timeToNextDataPacketAvg = 50s

# End node 2 (ID 1002)
**.loRaEndNodes[2].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[2].LoRaNodeApp.forcedDestinationId = 2000
**.loRaEndNodes[2].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[2].LoRaNodeApp.timeToFirstDataPacket = 60s
**.loRaEndNodes[2].LoRaNodeApp.numberOfPacketsPerDestination = 20
**.loRaEndNodes[2].LoRaNodeApp.sendPacketsContinuously = false
**.loRaEndNodes[2].LoRaNodeApp.timeToNextDataPacketMin = 45s
**.loRaEndNodes[2].LoRaNodeApp.timeToNextDataPacketMax = 55s
**.loRaEndNodes[2].LoRaNodeApp.timeToNextDataPacketAvg = 50s

# End node 3 (ID 1003)
**.loRaEndNodes[3].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[3].LoRaNodeApp.forcedDestinationId = 2000
**.loRaEndNodes[3].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[3].LoRaNodeApp.timeToFirstDataPacket = 60s
**.loRaEndNodes[3].LoRaNodeApp.numberOfPacketsPerDestination = 20
**.loRaEndNodes[3].LoRaNodeApp.sendPacketsContinuously = false
**.loRaEndNodes[3].LoRaNodeApp.timeToNextDataPacketMin = 45s
**.loRaEndNodes[3].LoRaNodeApp.timeToNextDataPacketMax = 55s
**.loRaEndNodes[3].LoRaNodeApp.timeToNextDataPacketAvg = 50s


# Use mobile turtle script instead of stationary (choose speed: 5mps, 7mps, 8mps, or 11mps)
**.loRaRescueNodes[*].mobility.turtleScript = xmldoc("turtle_patrol_11mps_2km.xml")


# Simulation window - Same as parent config
# With 20 packets per node at 50s avg interval: 1000s + 19*50s = 1950s per node
# All nodes transmit concurrently, so total time is still ~2000s + routing overhead
# Keep parent's 6500s limit for safety
sim-time-limit = 6500s
warmup-period = 0s
