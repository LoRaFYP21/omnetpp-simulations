[General]
# network
	network = LoRaMesh
	LoRaMesh.mapPath = "map/blu"
#	LoRaMesh.mapPath = "background/green"
	LoRaMesh.mapWidth = 20000 # width of the image of your map in meters
	LoRaMesh.mapHeight = 20000 # height of the image of your map in meters
	
#repeat
#	repeat = 25

# =================================================================
# ENHANCED LOGGING FOR ROUTING OBSERVATION
# =================================================================
	record-eventlog=true	    # Enable for detailed packet tracing

	cmdenv-status-frequency = 10s   # Status every 10 seconds for demo
	cmdenv-output-file = routing_demo_log.txt
	cmdenv-autoflush = true
	cmdenv-express-mode = false      # Disable for better observation
    **.vector-recording = true
	**.scalar-recording = true       # Enable for routing statistics

# random numbers generator

	rng-class = "cMersenneTwister"
	seed-set = ${processid}   # Use OS process id so positions vary each run

# simulation timing
	
	simtime-resolution = -10
	sim-time-limit = 500s     # Sufficient time for routing + data transmission
	**.loRaNodes[*].**.stopRoutingAfterDataDone = 500s
	**.loRaRescueNodes[*].**.stopRoutingAfterDataDone = 500s

	
	warmup-period = 0s          # No warmup - start immediately!

# =================================================================
# 50-NODE GRID DEPLOYMENT FOR ROUTING DEMONSTRATION
# =================================================================
# Grid arrangement: 50 nodes in 8x7 grid (7 columns, 8 rows, missing 6 nodes)
# Area: 20km x 20km with sufficient spacing for multi-hop communication
# Grid spacing: ~2.5km between nodes for realistic LoRa range

# Grid parameters
**.loRaNodes[*].deploymentType = "grid"
**.loRaNodes[*].minX = 1000m           # Start 1km from edge
**.loRaNodes[*].minY = 1000m           # Start 1km from edge  
**.loRaNodes[*].sepX = 2500m           # 2.5km horizontal spacing
**.loRaNodes[*].sepY = 2500m           # 2.5km vertical spacing

# Manual positioning for 50 nodes in 8x7 grid pattern
# Row 0 (7 nodes): 0-6
**.loRaNodes[0].initialX = 1000m
**.loRaNodes[0].initialY = 1000m
**.loRaNodes[1].initialX = 3500m
**.loRaNodes[1].initialY = 1000m
**.loRaNodes[2].initialX = 6000m
**.loRaNodes[2].initialY = 1000m
**.loRaNodes[3].initialX = 8500m
**.loRaNodes[3].initialY = 1000m
**.loRaNodes[4].initialX = 11000m
**.loRaNodes[4].initialY = 1000m
**.loRaNodes[5].initialX = 13500m
**.loRaNodes[5].initialY = 1000m
**.loRaNodes[6].initialX = 16000m
**.loRaNodes[6].initialY = 1000m

# Row 1 (7 nodes): 7-13
**.loRaNodes[7].initialX = 1000m
**.loRaNodes[7].initialY = 3500m
**.loRaNodes[8].initialX = 3500m
**.loRaNodes[8].initialY = 3500m
**.loRaNodes[9].initialX = 6000m
**.loRaNodes[9].initialY = 3500m
**.loRaNodes[10].initialX = 8500m
**.loRaNodes[10].initialY = 3500m
**.loRaNodes[11].initialX = 11000m
**.loRaNodes[11].initialY = 3500m
**.loRaNodes[12].initialX = 13500m
**.loRaNodes[12].initialY = 3500m
**.loRaNodes[13].initialX = 16000m
**.loRaNodes[13].initialY = 3500m

# Row 2 (7 nodes): 14-20
**.loRaNodes[14].initialX = 1000m
**.loRaNodes[14].initialY = 6000m
**.loRaNodes[15].initialX = 3500m
**.loRaNodes[15].initialY = 6000m
**.loRaNodes[16].initialX = 6000m
**.loRaNodes[16].initialY = 6000m
**.loRaNodes[17].initialX = 8500m
**.loRaNodes[17].initialY = 6000m
**.loRaNodes[18].initialX = 11000m
**.loRaNodes[18].initialY = 6000m
**.loRaNodes[19].initialX = 13500m
**.loRaNodes[19].initialY = 6000m
**.loRaNodes[20].initialX = 16000m
**.loRaNodes[20].initialY = 6000m

# Row 3 (7 nodes): 21-27
**.loRaNodes[21].initialX = 1000m
**.loRaNodes[21].initialY = 8500m
**.loRaNodes[22].initialX = 3500m
**.loRaNodes[22].initialY = 8500m
**.loRaNodes[23].initialX = 6000m
**.loRaNodes[23].initialY = 8500m
**.loRaNodes[24].initialX = 8500m
**.loRaNodes[24].initialY = 8500m
**.loRaNodes[25].initialX = 11000m
**.loRaNodes[25].initialY = 8500m
**.loRaNodes[26].initialX = 13500m
**.loRaNodes[26].initialY = 8500m
**.loRaNodes[27].initialX = 16000m
**.loRaNodes[27].initialY = 8500m

# Row 4 (7 nodes): 28-34
**.loRaNodes[28].initialX = 1000m
**.loRaNodes[28].initialY = 11000m
**.loRaNodes[29].initialX = 3500m
**.loRaNodes[29].initialY = 11000m
**.loRaNodes[30].initialX = 6000m
**.loRaNodes[30].initialY = 11000m
**.loRaNodes[31].initialX = 8500m
**.loRaNodes[31].initialY = 11000m
**.loRaNodes[32].initialX = 11000m
**.loRaNodes[32].initialY = 11000m
**.loRaNodes[33].initialX = 13500m
**.loRaNodes[33].initialY = 11000m
**.loRaNodes[34].initialX = 16000m
**.loRaNodes[34].initialY = 11000m

# Row 5 (7 nodes): 35-41
**.loRaNodes[35].initialX = 1000m
**.loRaNodes[35].initialY = 13500m
**.loRaNodes[36].initialX = 3500m
**.loRaNodes[36].initialY = 13500m
**.loRaNodes[37].initialX = 6000m
**.loRaNodes[37].initialY = 13500m
**.loRaNodes[38].initialX = 8500m
**.loRaNodes[38].initialY = 13500m
**.loRaNodes[39].initialX = 11000m
**.loRaNodes[39].initialY = 13500m
**.loRaNodes[40].initialX = 13500m
**.loRaNodes[40].initialY = 13500m
**.loRaNodes[41].initialX = 16000m
**.loRaNodes[41].initialY = 13500m

# Row 6 (7 nodes): 42-48
**.loRaNodes[42].initialX = 1000m
**.loRaNodes[42].initialY = 16000m
**.loRaNodes[43].initialX = 3500m
**.loRaNodes[43].initialY = 16000m
**.loRaNodes[44].initialX = 6000m
**.loRaNodes[44].initialY = 16000m
**.loRaNodes[45].initialX = 8500m
**.loRaNodes[45].initialY = 16000m
**.loRaNodes[46].initialX = 11000m
**.loRaNodes[46].initialY = 16000m
**.loRaNodes[47].initialX = 13500m
**.loRaNodes[47].initialY = 16000m
**.loRaNodes[48].initialX = 16000m
**.loRaNodes[48].initialY = 16000m

# Row 7 (1 node): 49 (center node for interesting routing patterns)
**.loRaNodes[49].initialX = 8500m
**.loRaNodes[49].initialY = 18500m

	
# Number of nodes - 50 relay nodes in grid formation
**.numberOfNodes = 50         # 50 relay nodes for comprehensive routing demo
**.numberOfEndNodes = 0       # No regular end nodes (using rescue nodes instead)
**.numberOfRescueNodes = 2    # Two RESCUE end nodes for this scenario
# power consumption features
**.loRaNodes[*].LoRaNic.radio.energyConsumerType = "LoRaEnergyConsumer"
**.loRaNodes[*].**.energySourceModule = "IdealEpEnergyStorage"
**.loRaNodes[*].LoRaNic.radio.energyConsumer.configFile = xmldoc("energyConsumptionParameters.xml")
**.loRaRescueNodes[*].LoRaNic.radio.energyConsumerType = "LoRaEnergyConsumer"
**.loRaRescueNodes[*].**.energySourceModule = "IdealEpEnergyStorage"
**.loRaRescueNodes[*].LoRaNic.radio.energyConsumer.configFile = xmldoc("energyConsumptionParameters.xml")

# general network features
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
**.constraintAreaMaxX = 20000m  # 20km x 20km area
**.constraintAreaMaxY = 20000m
**.constraintAreaMaxZ = 0m
**.delayer.config = xmldoc("cloudDelays.xml")
**.radio.radioMediumModule = "LoRaMedium"
**.LoRaMedium.pathLossType = "LoRaLogNormalShadowing"

**.d0=190m
**.sigma = 3.5
**.gamma = 3.3

**.minInterferenceTime = 0s

# network features
**.numberOfGateways = 0

# =================================================================
# COMMUNICATION PATTERN FOR ROUTING DEMONSTRATION  
# =================================================================

# -----------------------------------------------------------------
# AUTOMATIC ACK FUNCTIONALITY
# When a DATA packet reaches its destination node, the destination
# will automatically generate an ACK packet back to the source using
# the routing tables. ACK packets are forwarded by intermediate nodes
# just like DATA packets, using the same routing algorithms.
# This enables end-to-end acknowledgment in multi-hop scenarios.
# -----------------------------------------------------------------

# data packets generation - disable relay generation, only rescue end nodes communicate
**.sendPacketsContinuously = false #relay nodes don't generate packets

# ROUTING DEMO: Disable relay data generation, only end-to-end communication
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = false  #relays don't generate data packets

# COMMUNICATION :
**.numberOfDestinationsPerNode = 1 #Each node talks to 1 specific destination
**.dataPacketDefaultSize = 11B  #packet size
**.packetTTL = 20 #Sufficient TTL for long multi-hop paths

**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 60s    # Start data after 1 minute
**.loRaRescueNodes[*].LoRaNodeApp.timeToFirstDataPacket = 60s    # Align end-node data start

**.timeToNextDataPacketDist = "uniform"
**.timeToNextDataPacketMin = 0s

**.timeToNextDataPacketMax = ${timeToNextDataPacketMax=10s}  # data packets are created every 1-10Secs

**.timeToNextDataPacketAvg = 5s   # Data every 5 seconds for easy observation

# forwarded packets
**.numberOfPacketsToForward = 0 #0 for no limit
**.ownDataPriority = 0 #0: forward priority; 1: own data priority

**.loRaNodes[*].LoRaNodeApp.routingMetric = 3  # HOP_COUNT routing - relay nodes use unicast with routing tables

# routing settings - ENHANCED FOR ROUTING DEMO
**.routeDiscovery = true
**.routeTimeout = 600s                 # Longer route validity for stability
**.storeBestRouteOnly = true           # Keep only the best route per destination
**.getRoutesFromDataPackets = true    # Learn from all packets
**.routingPacketPriority = 0.5
**.routingPacketMaxSize = 12B
**.timeToFirstRoutingPacket = 5s+uniform(0s, 5s)   # Start routing discovery immediately
**.timeToNextRoutingPacketDist = "uniform"
**.timeToNextRoutingPacketMin = 0s
**.timeToNextRoutingPacketMax = 10s    # Very frequent routing updates
**.timeToNextRoutingPacketAvg = 5s

# -----------------------------------------------------------------
# ROUTING TABLE FREEZE (stabilize topology after convergence)
# When enabled, once a node learns routingFreezeUniqueCount unique
# destination entries in its single-metric routing table, it will:
#  - Log REACHED<threshold> and FREEZE events to delivered_packets/routing_convergence.csv
#  - Stop accepting further routing updates / changes
#  - Preserve existing routes indefinitely (validity extended far future)
# This allows performance evaluation with a stable routing snapshot.
# Disable (false) to allow uous adaptation.
# -----------------------------------------------------------------
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = true
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 51   # Require unique routes to all other 49 nodes
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s  # How long to keep frozen routes valid (avoid huge like 1e9s)
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true  # Stop routing beacons when all nodes have unique routes to all destinations

# duty cycle
**.dutyCycle = 0.01
**.enforceDutyCycle = ${enforceDutyCycle = true, false}

# nodes placement (overridden by individual positions above)
**.loRaNodes[*].minX = 0m
**.loRaNodes[*].minY = 0m
**.loRaNodes[*].maxX = 20000m 
**.loRaNodes[*].maxY = 20000m 

# Random placement for RESCUE end nodes on every run (circle deployment)
**.loRaRescueNodes[*].deploymentType = "circle"
**.loRaRescueNodes[*].rad = 9000
**.loRaRescueNodes[*].centX = 10000
**.loRaRescueNodes[*].centY = 10000
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 3   # End nodes use same routing as relays (HOP_COUNT) for proper unicast forwarding
**.loRaRescueNodes[*].iAmRescue = true   # Identify rescue nodes; nodeId offsets to 2000+
 



**.LoRaMedium.mediumLimitCacheType = "LoRaMediumCache"
**.LoRaMedium.rangeFilter = "communicationRange"
**.LoRaMedium.neighborCacheType = "LoRaNeighborCache"
**.LoRaMedium.neighborCache.range = 3000m  # Suitable for 2.5km grid spacing
**.LoRaMedium.neighborCache.refillPeriod = 3000s

# LoRa settings: channel
**.loRaNodes[*].**.initFromDisplayString = false
**.loRaNodes[*].**initialLoRaSF = 7
**.loRaNodes[*].**minLoRaSF = 7
**.loRaNodes[*].**maxLoRaSF = 12
**.loRaNodes[*].**initialLoRaBW = 125 kHz
**.loRaNodes[*].**initialLoRaCR = 1
**.loRaNodes[*].**initialLoRaTP = 17dBm
**.loRaNodes[*].**initialLoRaCAD = true
**.loRaNodes[*].**initialLoRaCADatt = 0dB

# Rescue end-node radio initialization aligned with relay nodes
**.loRaRescueNodes[*].**.initFromDisplayString = false
**.loRaRescueNodes[*].**initialLoRaSF = 7
**.loRaRescueNodes[*].**minLoRaSF = 7
**.loRaRescueNodes[*].**maxLoRaSF = 12
**.loRaRescueNodes[*].**initialLoRaBW = 125 kHz
**.loRaRescueNodes[*].**initialLoRaCR = 1
**.loRaRescueNodes[*].**initialLoRaTP = 17dBm
**.loRaRescueNodes[*].**initialLoRaCAD = true
**.loRaRescueNodes[*].**initialLoRaCADatt = 0dB

# =================================================================
# END-TO-END COMMUNICATION: Rescue node 2000 floods to reach 2001
# Rescue end node 0 (ID 2000) continuously sends data to rescue end node 1 (ID 2001)
# End nodes must use FLOODING (routingMetric=1) so the initial TX is broadcast.
# Relays also use FLOODING (routingMetric=1) to rebroadcast and propagate the packet.
# =================================================================
**.loRaRescueNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true
**.loRaRescueNodes[0].LoRaNodeApp.sendPacketsContinuously = true
**.loRaRescueNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaRescueNodes[0].LoRaNodeApp.forcedDestinationId = 2001
**.loRaRescueNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaRescueNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 1
**.loRaRescueNodes[0].LoRaNodeApp.timeToFirstDataPacket = 60s    # Start after minimal warmup
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 15s   # Send every 10-15 seconds  
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 12s

# Ensure the other rescue end node doesn't generate traffic
**.loRaRescueNodes[1].LoRaNodeApp.sendPacketsContinuously = false

# FLOODING MODE: ensure broadcast behavior
**.routeDiscovery = false                       # No routing beacons in flooding
**.loRaNodes[*].LoRaNodeApp.routingMetric = 1   # Relays flood/broadcast
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 1 # End nodes flood TX (no forwarding implied by iAmEnd + no-forward checks)

# =================================================================
# ROUTING ALGORITHM CONFIGURATIONS FOR EASY TESTING
# =================================================================

[Config HopCount_Routing] 
# Minimum hop count - Shortest path
**.loRaNodes[*].LoRaNodeApp.routingMetric = 3

[Config ETX_Routing]
# ETX (Expected Transmission Count) - reliability-based routing
**.loRaNodes[*].LoRaNodeApp.routingMetric = 6

[Config RSSI_Routing]
# RSSI-based routing - signal strength
**.loRaNodes[*].LoRaNodeApp.routingMetric = 4

# =================================================================
# QUICK DEMO CONFIGURATIONS
# =================================================================

[Config QuickDemo_HopCount_Grid50]
extends = HopCount_Routing  
# Ultra-fast hop count routing demo with 50-node grid
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 3s
**.timeToNextRoutingPacketAvg = 2s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 150s
**.timeToNextDataPacketMax = 8s
**.timeToNextDataPacketAvg = 5s
warmup-period = 0s
sim-time-limit = 2000s

# Communication pattern - corner to corner communication
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true     
**.numberOfDestinationsPerNode = 1
**.sendPacketsContinuously = false

# Corner-to-corner communication: node 0 (bottom-left) to node 48 (top-right)
**.loRaNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaNodes[0].LoRaNodeApp.forcedDestinationId = 5

# Routing freeze settings for grid
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false  # Disable for quick demo
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 49
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s
#-------------------------------------------------------------------------------------------

# =================================================================
# REACHABILITY TEST: Node 0 to All Other Nodes (1-49)  
# =================================================================
[Config Node0ToAllNodes_Test]
extends = HopCount_Routing
# Test configuration to send packets from node 0 to every other node
# This will help identify which nodes are unreachable from node 0

# Only node 0 sends packets
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true     
**.numberOfDestinationsPerNode = 0  # 0 means all other nodes (auto-selected)
**.sendPacketsContinuously = true   # Keep sending packets

# Timing: Give routing time to converge, then start data transmission
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 50s
**.timeToNextRoutingPacketAvg = 45s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 150s     # Start data after routing converges

# Send packets with sufficient spacing
**.timeToNextDataPacketMax = 20s     # 10 seconds between packets 
**.timeToNextDataPacketAvg = 15s      # Average 8 seconds

# Routing settings optimized for reachability test
# Routing freeze settings for grid
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false  # Disable for quick demo
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 51
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s
**.routeTimeout = 800s               # Long route validity
**.packetTTL = 25                   # High TTL for long multi-hop paths

**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true  # Stop routing beacons when all nodes have unique routes to all destinations

# Extended simulation time to complete all transmissions
sim-time-limit = 2000s              # Shorter time first to test
warmup-period = 0s

# Duty cycle settings - disable to avoid interference with systematic testing
**.enforceDutyCycle = false         # Disable for comprehensive reachability test

# =================================================================
# SINGLE PACKET PER DESTINATION: Node 0 to All Other Nodes (1-49)  
# =================================================================
[Config Node0ToAllNodes_SinglePacket]
extends = HopCount_Routing
# Send exactly ONE packet from node 0 to each of the 49 destinations
# No continuous transmission - just one round of packets

# Only node 0 sends packets
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true     
**.numberOfDestinationsPerNode = 0  # 0 means all other nodes (auto-selected)
**.sendPacketsContinuously = false  # CRITICAL: Send only initial batch, no continuous packets
**.numberOfPacketsPerDestination = 1  # Exactly 1 packet per destination

# Use a different result file name to avoid conflicts
output-scalar-file = "Node0_SinglePacket_${configname}_${datetime}.sca"
output-vector-file = "Node0_SinglePacket_${configname}_${datetime}.vec"

# Timing: Give routing time to converge, then send all packets quickly
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 3s
**.timeToNextRoutingPacketAvg = 2s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 200s     # Start data after routing converges

# Since sendPacketsContinuously=false, these timing parameters won't be used for additional packets
**.timeToNextDataPacketMax = 10s      # Not used with sendPacketsContinuously=false
**.timeToNextDataPacketAvg = 10s      # Not used with sendPacketsContinuously=false

# Routing settings optimized for reachability test
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false  # Keep adapting for reliability
**.routeTimeout = 800s               # Long route validity
**.packetTTL = 25                   # High TTL for long multi-hop paths

# Shorter simulation time since we only send 49 packets total
sim-time-limit = 600s               # Sufficient time for all 49 packets to be delivered
warmup-period = 0s

# Duty cycle settings - disable to avoid interference with systematic testing
**.enforceDutyCycle = false         # Disable for single-packet reachability test

# =================================================================
# SIMPLE TEST: Node 0 to Specific Nodes (Manual Testing)
# =================================================================
[Config Node0ToNode5_Simple]
extends = HopCount_Routing
# Simple test to verify the configuration works - send from node 0 to node 10
# Ultra-fast hop count routing demo with 50-node grid
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 3s
**.timeToNextRoutingPacketAvg = 2s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 150s
**.timeToNextDataPacketMax = 8s
**.timeToNextDataPacketAvg = 5s
warmup-period = 0s
sim-time-limit = 2000s

**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true
**.numberOfDestinationsPerNode = 1
**.sendPacketsContinuously = false

**.loRaNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaNodes[0].LoRaNodeApp.forcedDestinationId = 5
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 16   # Adjust if you want earlier/later freeze
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s


# =================================================================
#End1000 generates, relays smart-broadcast to End1001 (RESCUE)
# - Preserve existing 50 relay nodes + 2 rescue end nodes placement from base
# - No routing beacons (pure data-plane forwarding)
# - Rescue end nodes do not forward (iAmEnd=true); only 1000 generates data
# - Relays forward with SMART_BROADCAST until destination 1001 receives
# =================================================================
[Config No_Duplicate_flood_End1000_to_End1001]
# Keep node counts and base placements as defined in General
network = LoRaMesh
**.numberOfNodes = 50
**.numberOfRescueNodes = 2

# Disable routing beacons to match Wellington behavior
**.routeDiscovery = false

# Relays use SMART_BROADCAST; Rescue end nodes are marked as end (no forwarding)
**.loRaNodes[*].LoRaNodeApp.routingMetric = 2      # SMART_BROADCAST_SINGLE_SF for relays
**.loRaRescueNodes[*].iAmRescue = true             # Rescue classification for 2000+ ID offset
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 1   # Flood TX from end nodes; forwarding still blocked by iAmEnd

# Ensure only rescue end node 0 generates data to rescue end node 1
**.sendPacketsContinuously = false                  # Relays do not generate data
**.loRaRescueNodes[1].LoRaNodeApp.sendPacketsContinuously = false
**.loRaRescueNodes[0].LoRaNodeApp.sendPacketsContinuously = true
**.loRaRescueNodes[0].LoRaNodeApp.timeToFirstDataPacket = 120s
**.loRaRescueNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaRescueNodes[0].LoRaNodeApp.forcedDestinationId = 2001
**.loRaRescueNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaRescueNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 1
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 15s
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 12s

# General data-plane parameters similar to Wellington
# Do NOT set a global numberOfDestinationsPerNode here; it can
# cause relays to generate a one-off packet at their timeToFirstDataPacket.
**.dataPacketDefaultSize = 11B
**.packetTTL = 20

# Explicitly prevent relay data generation (one-shot or continuous)
**.loRaNodes[*].LoRaNodeApp.sendPacketsContinuously = false
**.loRaNodes[*].LoRaNodeApp.numberOfPacketsPerDestination = 0
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 1000000s

# Optional: keep duty cycle as per base; uncomment to disable during tests
#**.enforceDutyCycle = false

# Recording for path analysis (optional; rely on existing logging setup)
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true

# Reasonable simulation time window
sim-time-limit = 1000s
warmup-period = 0s


# =================================================================
# MOBILITY VARIANT: Same as DV_End1000_to_End1001 but with mobility
# Enables MassMobility for rescue end nodes so they move during the
# simulation within the global constraint area already defined above.
# =================================================================
[Config DV_End1000_to_End1001_Mobility]
extends = DV_End1000_to_End1001

# Switch rescue nodes to a mobility model and set higher, more-dynamic speed
**.loRaRescueNodes[*].mobilityType = "MassMobility"
# Use randomized speeds between 3--7 m/s for more variation
**.loRaRescueNodes[*].mobility.speed = uniform(3mps, 7mps)
# Make direction changes more frequent and larger so nodes move more dynamically
**.loRaRescueNodes[*].mobility.changeInterval = 5s
**.loRaRescueNodes[*].mobility.angleDelta = uniform(-180deg, 180deg)

# (Optional) If you prefer a single fixed higher speed, replace the above `uniform(...)` with a literal, e.g. `5mps`.

# Start MassMobility from the same circle distribution as end nodes
# Start MassMobility from the same circle distribution as end nodes
# Use radians directly (avoid rad() conversion): angle ~ U(0, 2*pi)
**.loRaRescueNodes[*].mobility.initialX = 10000m + sqrt(uniform(0,1)) * 9000m * cos(uniform(0, 2*acos(-1)))
**.loRaRescueNodes[*].mobility.initialY = 10000m + sqrt(uniform(0,1)) * 9000m * sin(uniform(0, 2*acos(-1)))
# =================================================================
# END-TO-END: Rescue end node 1000 continuously sends to 1001
# End nodes broadcast, relays forward using unicast routing tables
# =================================================================
[Config DV_End1000_to_End1001]
extends = HopCount_Routing

# Keep routing behavior and logging as in base
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true

# Switch rescue nodes to a mobility model and set basic speed
**.loRaRescueNodes[*].mobilityType = "MassMobility"
**.loRaRescueNodes[*].mobility.speed = 2mps
# Optional: tweak mobility randomness
**.loRaRescueNodes[*].mobility.changeInterval = 20s
**.loRaRescueNodes[*].mobility.angleDelta = uniform(-30deg, 30deg)



# Ensure mobility does not use display-string positions (prevents top-left clustering)
**.loRaRescueNodes[*].**.initFromDisplayString = false


**.loRaNodes[*].LoRaNodeApp.recordPerPacketSignals = false
**.loRaRescueNodes[*].LoRaNodeApp.recordPerPacketSignals = false


# Stop routing beacons after relay convergence; keep forwarding enabled
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = true
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 3
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true

# Enable continuous data generation from rescue end node 0 (ID 2000) to rescue end node 1 (ID 2001)
**.sendPacketsContinuously = false  # Relays don't generate data

# Disable data generation for relay nodes and unwanted end nodes
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 1e6s
**.loRaRescueNodes[1].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Enable continuous data generation only at rescue end node 0 (ID 2000)
**.loRaRescueNodes[0].LoRaNodeApp.sendPacketsContinuously = false
**.loRaRescueNodes[0].LoRaNodeApp.timeToFirstDataPacket = 120s
**.loRaRescueNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaRescueNodes[0].LoRaNodeApp.forcedDestinationId = 2001
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 20s
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 15s

# Longer simulation to observe multiple packet exchanges
#sim-time-limit = 1000s

# Ensure end nodes participate in routing beacons so relays can learn routes to 2000/2001
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 3
# Minimum hop count - Shortest path
**.loRaNodes[*].LoRaNodeApp.routingMetric = 3

# Timing for routing beacons so routes propagate before the data
**.timeToFirstRoutingPacket = 5s
**.timeToNextRoutingPacketMax = 10s
**.timeToNextRoutingPacketAvg = 5s

# Reasonable simulation time
sim-time-limit = 1000s
warmup-period = 0s
# =================================================================
# END NODE â†’ RESCUE NODE: Single packet from end node (ID 1000) to rescue (ID 2000)
# - Adds one classic end node (`endNode` using `LoRaNodeApp`) alongside rescue nodes
# - Uses hop-count routing so relays learn unicast routes before data
# - End node sends exactly one packet to the first rescue node
# =================================================================
[Config EndNode1000_to_Rescue2000]
extends = HopCount_Routing

# Keep routing behavior and logging as in base
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true

# Node counts: keep existing 50 relays, add 1 end node and 1 rescue node
network = LoRaMesh
**.numberOfNodes = 50
**.numberOfEndNodes = 1
**.numberOfRescueNodes = 1   # Need node IDs 2000 and 2001 (destination)

# Explicitly enable route discovery in this config (overrides any global flooding settings)
**.routeDiscovery = true
**.timeToFirstRoutingPacket = 5s
**.timeToNextRoutingPacketMax = 10s
**.timeToNextRoutingPacketAvg = 5s

# Ensure all three node types emit routing beacons with the same timers
**.loRaNodes[*].LoRaNodeApp.routeDiscovery = true
**.loRaNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 5s
**.loRaNodes[*].LoRaNodeApp.timeToNextRoutingPacketMax = 10s
**.loRaNodes[*].LoRaNodeApp.timeToNextRoutingPacketAvg = 5s

**.loRaRescueNodes[*].LoRaNodeApp.routeDiscovery = true
**.loRaRescueNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 5s
**.loRaRescueNodes[*].LoRaNodeApp.timeToNextRoutingPacketMax = 10s
**.loRaRescueNodes[*].LoRaNodeApp.timeToNextRoutingPacketAvg = 5s

**.loRaEndNodes[*].LoRaNodeApp.routeDiscovery = true
**.loRaEndNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 5s
**.loRaEndNodes[*].LoRaNodeApp.timeToNextRoutingPacketMax = 10s
**.loRaEndNodes[*].LoRaNodeApp.timeToNextRoutingPacketAvg = 5s


# Stop routing beacons after relay convergence; keep forwarding enabled
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = true
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 3
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true

**.loRaEndNodes[*].iAmEnd = true
**.loRaRescueNodes[*].iAmRescue = true

# Enable continuous data generation from end node 0 (ID 1000) to rescue node 1 (ID 1001)
**.sendPacketsContinuously = false  # Relays don't generate data
# Disable data generation for relay nodes and unwanted end nodes
#**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 1e6s
#**.loRaRescueNodes[1].LoRaNodeApp.timeToFirstDataPacket = 1e6s
**.loRaRescueNodes[0].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Power consumption features for end node (match relays/rescue nodes)
**.loRaEndNodes[*].LoRaNic.radio.energyConsumerType = "LoRaEnergyConsumer"
**.loRaEndNodes[*].**.energySourceModule = "IdealEpEnergyStorage"
**.loRaEndNodes[*].LoRaNic.radio.energyConsumer.configFile = xmldoc("energyConsumptionParameters.xml")

# Ensure end/rescue nodes participate in routing (unicast forwarding via relays)
**.loRaNodes[*].LoRaNodeApp.routingMetric = 3
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 3
**.loRaEndNodes[*].LoRaNodeApp.routingMetric = 3

# Prevent relays from generating data
**.sendPacketsContinuously = false
**.loRaNodes[*].LoRaNodeApp.sendPacketsContinuously = false
**.loRaNodes[*].LoRaNodeApp.numberOfPacketsPerDestination = 0
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Place the rescue node randomly on the circle each run
**.loRaRescueNodes[*].deploymentType = "circle"
**.loRaRescueNodes[*].rad = 9000
**.loRaRescueNodes[*].centX = 10000
**.loRaRescueNodes[*].centY = 10000
**.loRaRescueNodes[*].**.initFromDisplayString = false

**.loRaNodes[*].LoRaNodeApp.recordPerPacketSignals = false
**.loRaRescueNodes[*].LoRaNodeApp.recordPerPacketSignals = false
**.loRaEndNodes[*].LoRaNodeApp.recordPerPacketSignals = false



# Make rescue nodes mobile (MassMobility), mirroring DV_End1000_to_End1001_Mobility
**.loRaRescueNodes[*].mobilityType = "MassMobility"
**.loRaRescueNodes[*].mobility.speed = uniform(3mps, 7mps)
**.loRaRescueNodes[*].mobility.changeInterval = 5s
**.loRaRescueNodes[*].mobility.angleDelta = uniform(-180deg, 180deg)
**.loRaRescueNodes[*].mobility.initialX = 10000m + sqrt(uniform(0,1)) * 9000m * cos(uniform(0, 2*acos(-1)))
**.loRaRescueNodes[*].mobility.initialY = 10000m + sqrt(uniform(0,1)) * 9000m * sin(uniform(0, 2*acos(-1)))

**.loRaEndNodes[*].**.initFromDisplayString = false

# Random placement for END nodes on every run (circle deployment)
**.loRaEndNodes[*].deploymentType = "circle"
**.loRaEndNodes[*].rad = 9000
**.loRaEndNodes[*].centX = 10000
**.loRaEndNodes[*].centY = 10000

# End node sends exactly one packet to the rescue node (ID 2000)
**.loRaEndNodes[0].LoRaNodeApp.sendPacketsContinuously = false
**.loRaEndNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaEndNodes[0].LoRaNodeApp.forcedDestinationId = 2000   # Send to rescue node ID 2001
**.loRaEndNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaEndNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 1
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 120s

# Common data-plane parameters
**.dataPacketDefaultSize = 11B
**.packetTTL = 20


# Simulation window
sim-time-limit = 800s
warmup-period = 0s

# =================================================================
# DSDV VARIANT: End node (ID 1000) sends to rescue node (ID 2000)
# Uses DSDV protocol with proactive updates (incremental + periodic full)
# Extends the existing EndNode1000_to_Rescue2000 scenario
# =================================================================
[Config EndNode1000_to_Rescue2000_DSDV]
extends = EndNode1000_to_Rescue2000

# Select DSDV protocol for ALL node types (legacy remains default elsewhere)
**.routingProtocol = "dsdv"
**.loRaNodes[*].LoRaNodeApp.routingProtocol = "dsdv"
**.loRaEndNodes[*].LoRaNodeApp.routingProtocol = "dsdv"
**.loRaRescueNodes[*].LoRaNodeApp.routingProtocol = "dsdv"

# DSDV timers and parameters (apply to all node types)
**.dsdvIncrementalPeriod = 15s
**.dsdvFullUpdatePeriod = 120s
**.dsdvTriggeredMinInterval = 3s
**.dsdvRouteLifetime = 600s
**.dsdvTimerJitterMin = 0.2s
**.dsdvTimerJitterMax = 2s
**.dsdvNeighborTimeout = 40s
**.dsdvUseChunking = true
**.dsdvMaxEntriesPerPacket = 10

# Explicitly set DSDV parameters for end nodes
**.loRaEndNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 15s
**.loRaEndNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 120s
**.loRaEndNodes[*].LoRaNodeApp.dsdvTimerJitterMin = 0.2s
**.loRaEndNodes[*].LoRaNodeApp.dsdvTimerJitterMax = 2s

# Explicitly set DSDV parameters for rescue nodes
**.loRaRescueNodes[*].LoRaNodeApp.dsdvIncrementalPeriod = 15s
**.loRaRescueNodes[*].LoRaNodeApp.dsdvFullUpdatePeriod = 120s
**.loRaRescueNodes[*].LoRaNodeApp.dsdvTimerJitterMin = 0.2s
**.loRaRescueNodes[*].LoRaNodeApp.dsdvTimerJitterMax = 2s

# Disable legacy convergence features for ALL node types (designed for beacon-based protocol)
# DSDV uses proactive periodic updates and should never freeze/stop
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false
**.loRaEndNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false
**.loRaEndNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false
**.loRaRescueNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false
**.loRaRescueNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = false

# Disable legacy routing beacon timers - DSDV has its own periodic timers
# Setting very high values effectively disables legacy beacons
**.loRaNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 1000000s
**.loRaEndNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 1000000s
**.loRaRescueNodes[*].LoRaNodeApp.timeToFirstRoutingPacket = 1000000s

# CRITICAL: ALL nodes use routingMetric=3 to participate in DSDV routing protocol
# This ensures end/rescue nodes send DSDV packets so relays learn routes TO them
# Data forwarding behavior is determined by node TYPE, not routingMetric:
#   - End/rescue nodes (isEndNodeHost/isRescueNodeHost): Always broadcast data packets
#   - Relay nodes: Use DSDV routing tables for unicast forwarding
# This matches legacy routing architecture (see DV_End1000_to_End1001 and EndNode1000_to_Rescue2000)
**.loRaNodes[*].LoRaNodeApp.routingMetric = 3       # Relay nodes use routing tables
**.loRaEndNodes[*].LoRaNodeApp.routingMetric = 3    # End nodes send DSDV packets, broadcast data
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 3 # Rescue nodes send DSDV packets, broadcast data

# Route discovery enabled for ALL nodes to participate in DSDV protocol
**.loRaNodes[*].LoRaNodeApp.routeDiscovery = true
**.loRaEndNodes[*].LoRaNodeApp.routeDiscovery = true
**.loRaRescueNodes[*].LoRaNodeApp.routeDiscovery = true

# Delay data transmission to allow DSDV routes to propagate first
# DSDV full updates occur at ~120s, so data should start after that
**.loRaEndNodes[0].LoRaNodeApp.timeToFirstDataPacket = 180s

# =================================================================
# WELLINGTON MAP VARIANT: DSDV with 21 relay nodes (Wellington topology)
# Uses Wellington map and node positions from wellington_original.ini
# =================================================================
[Config EndNode1000_to_Rescue2000_DSDV_Wellington]
extends = EndNode1000_to_Rescue2000_DSDV

cmdenv-express-mode = false
# Also save logs to file when running in Qtenv
cmdenv-output-file = wellington_console_output.txt
cmdenv-redirect-output = true  # Enable file output even in Qtenv mode

# Enable INFO-level logging for DSDV debug messages in LoRaNodeApp
**.LoRaNodeApp.cmdenv-log-level = info
#**.LoRaNodeApp.qtenv-log-level = info

# Wellington map and area
LoRaMesh.mapPath = "map/wellington"
LoRaMesh.mapWidth = 9824  # Wellington map dimensions
LoRaMesh.mapHeight = 9824
**.constraintAreaMaxX = 10000m
**.constraintAreaMaxY = 10000m

# 21 relay nodes instead of 50
**.numberOfNodes = 21

# Override grid deployment - use manual positioning instead
**.loRaNodes[*].deploymentType = "manual"

# Wellington relay node positions (21 nodes)
**.loRaNodes[0].initialX = 5000m
**.loRaNodes[0].initialY = 5000m

**.loRaNodes[1].initialX = 0m
**.loRaNodes[1].initialY = 2120m

**.loRaNodes[2].initialX = 0m
**.loRaNodes[2].initialY = 4090m

**.loRaNodes[3].initialX = 0m
**.loRaNodes[3].initialY = 6050m

**.loRaNodes[4].initialX = 0m
**.loRaNodes[4].initialY = 8070m

**.loRaNodes[5].initialX = 2110m
**.loRaNodes[5].initialY = 0m

**.loRaNodes[6].initialX = 2070m
**.loRaNodes[6].initialY = 2050m

**.loRaNodes[7].initialX = 2100m
**.loRaNodes[7].initialY = 4050m

**.loRaNodes[8].initialX = 2010m
**.loRaNodes[8].initialY = 6100m

**.loRaNodes[9].initialX = 2240m
**.loRaNodes[9].initialY = 8010m

**.loRaNodes[10].initialX = 4080m
**.loRaNodes[10].initialY = 0m

**.loRaNodes[11].initialX = 4100m
**.loRaNodes[11].initialY = 2090m

**.loRaNodes[12].initialX = 4050m
**.loRaNodes[12].initialY = 4100m

**.loRaNodes[13].initialX = 4020m
**.loRaNodes[13].initialY = 6030m

**.loRaNodes[14].initialX = 4070m
**.loRaNodes[14].initialY = 8110m

**.loRaNodes[15].initialX = 6100m
**.loRaNodes[15].initialY = 4070m

**.loRaNodes[16].initialX = 6040m
**.loRaNodes[16].initialY = 6090m

**.loRaNodes[17].initialX = 6050m
**.loRaNodes[17].initialY = 8040m

**.loRaNodes[18].initialX = 8100m
**.loRaNodes[18].initialY = 4070m

**.loRaNodes[19].initialX = 8040m
**.loRaNodes[19].initialY = 6080m

**.loRaNodes[20].initialX = 8090m
**.loRaNodes[20].initialY = 8010m

# Adjust placement for Wellington area (smaller than 20km grid)
# End nodes (1 node, ID 1000) and Rescue nodes (1 node, ID 2000) use circle deployment
**.loRaEndNodes[*].deploymentType = "circle"
**.loRaEndNodes[*].rad = 4000
**.loRaEndNodes[*].centX = 5000
**.loRaEndNodes[*].centY = 5000

**.loRaRescueNodes[*].deploymentType = "circle"
**.loRaRescueNodes[*].rad = 4000
**.loRaRescueNodes[*].centX = 5000
**.loRaRescueNodes[*].centY = 5000

# MassMobility parameters for rescue nodes
**.loRaRescueNodes[*].mobility.changeInterval = truncnormal(2s, 0.5s)
**.loRaRescueNodes[*].mobility.changeAngleBy = normal(0deg, 30deg)
**.loRaRescueNodes[*].mobility.speed = truncnormal(15mps, 5mps)

# Adjust neighbor cache for Wellington area
**.LoRaMedium.neighborCache.range = 2600m  # Same as wellington_original

# Update routing freeze threshold for 21 nodes (instead of 50)
# Each node should learn routes to: 20 other relays + 1 end (1000) + 1 rescue (2000) = 22 total
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 22

