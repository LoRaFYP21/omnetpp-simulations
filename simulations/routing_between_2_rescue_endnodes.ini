[General]
# network
	network = LoRaMesh
	LoRaMesh.mapPath = "map/blu"
#	LoRaMesh.mapPath = "background/green"
	LoRaMesh.mapWidth = 20000 # width of the image of your map in meters
	LoRaMesh.mapHeight = 20000 # height of the image of your map in meters
	
#repeat
#	repeat = 25

# =================================================================
# ENHANCED LOGGING FOR ROUTING OBSERVATION
# =================================================================
	record-eventlog=true	    # Enable for detailed packet tracing

	cmdenv-status-frequency = 10s   # Status every 10 seconds for demo
	cmdenv-output-file = routing_demo_log.txt
	cmdenv-autoflush = true
	cmdenv-express-mode = false      # Disable for better observation
    **.vector-recording = true
	**.scalar-recording = true       # Enable for routing statistics

# random numbers generator

	rng-class = "cMersenneTwister"
	seed-set = ${processid}   # Use OS process id so positions vary each run

# simulation timing
	
	simtime-resolution = -10
	sim-time-limit = 500s     # Sufficient time for routing + data transmission
	**.loRaNodes[*].**.stopRoutingAfterDataDone = 500s
	**.loRaRescueNodes[*].**.stopRoutingAfterDataDone = 500s

	
	warmup-period = 0s          # No warmup - start immediately!

# =================================================================
# 50-NODE GRID DEPLOYMENT FOR ROUTING DEMONSTRATION
# =================================================================
# Grid arrangement: 50 nodes in 8x7 grid (7 columns, 8 rows, missing 6 nodes)
# Area: 20km x 20km with sufficient spacing for multi-hop communication
# Grid spacing: ~2.5km between nodes for realistic LoRa range

# Grid parameters
**.loRaNodes[*].deploymentType = "grid"
**.loRaNodes[*].minX = 1000m           # Start 1km from edge
**.loRaNodes[*].minY = 1000m           # Start 1km from edge  
**.loRaNodes[*].sepX = 2500m           # 2.5km horizontal spacing
**.loRaNodes[*].sepY = 2500m           # 2.5km vertical spacing

# Manual positioning for 50 nodes in 8x7 grid pattern
# Row 0 (7 nodes): 0-6
**.loRaNodes[0].initialX = 1000m
**.loRaNodes[0].initialY = 1000m
**.loRaNodes[1].initialX = 3500m
**.loRaNodes[1].initialY = 1000m
**.loRaNodes[2].initialX = 6000m
**.loRaNodes[2].initialY = 1000m
**.loRaNodes[3].initialX = 8500m
**.loRaNodes[3].initialY = 1000m
**.loRaNodes[4].initialX = 11000m
**.loRaNodes[4].initialY = 1000m
**.loRaNodes[5].initialX = 13500m
**.loRaNodes[5].initialY = 1000m
**.loRaNodes[6].initialX = 16000m
**.loRaNodes[6].initialY = 1000m

# Row 1 (7 nodes): 7-13
**.loRaNodes[7].initialX = 1000m
**.loRaNodes[7].initialY = 3500m
**.loRaNodes[8].initialX = 3500m
**.loRaNodes[8].initialY = 3500m
**.loRaNodes[9].initialX = 6000m
**.loRaNodes[9].initialY = 3500m
**.loRaNodes[10].initialX = 8500m
**.loRaNodes[10].initialY = 3500m
**.loRaNodes[11].initialX = 11000m
**.loRaNodes[11].initialY = 3500m
**.loRaNodes[12].initialX = 13500m
**.loRaNodes[12].initialY = 3500m
**.loRaNodes[13].initialX = 16000m
**.loRaNodes[13].initialY = 3500m

# Row 2 (7 nodes): 14-20
**.loRaNodes[14].initialX = 1000m
**.loRaNodes[14].initialY = 6000m
**.loRaNodes[15].initialX = 3500m
**.loRaNodes[15].initialY = 6000m
**.loRaNodes[16].initialX = 6000m
**.loRaNodes[16].initialY = 6000m
**.loRaNodes[17].initialX = 8500m
**.loRaNodes[17].initialY = 6000m
**.loRaNodes[18].initialX = 11000m
**.loRaNodes[18].initialY = 6000m
**.loRaNodes[19].initialX = 13500m
**.loRaNodes[19].initialY = 6000m
**.loRaNodes[20].initialX = 16000m
**.loRaNodes[20].initialY = 6000m

# Row 3 (7 nodes): 21-27
**.loRaNodes[21].initialX = 1000m
**.loRaNodes[21].initialY = 8500m
**.loRaNodes[22].initialX = 3500m
**.loRaNodes[22].initialY = 8500m
**.loRaNodes[23].initialX = 6000m
**.loRaNodes[23].initialY = 8500m
**.loRaNodes[24].initialX = 8500m
**.loRaNodes[24].initialY = 8500m
**.loRaNodes[25].initialX = 11000m
**.loRaNodes[25].initialY = 8500m
**.loRaNodes[26].initialX = 13500m
**.loRaNodes[26].initialY = 8500m
**.loRaNodes[27].initialX = 16000m
**.loRaNodes[27].initialY = 8500m

# Row 4 (7 nodes): 28-34
**.loRaNodes[28].initialX = 1000m
**.loRaNodes[28].initialY = 11000m
**.loRaNodes[29].initialX = 3500m
**.loRaNodes[29].initialY = 11000m
**.loRaNodes[30].initialX = 6000m
**.loRaNodes[30].initialY = 11000m
**.loRaNodes[31].initialX = 8500m
**.loRaNodes[31].initialY = 11000m
**.loRaNodes[32].initialX = 11000m
**.loRaNodes[32].initialY = 11000m
**.loRaNodes[33].initialX = 13500m
**.loRaNodes[33].initialY = 11000m
**.loRaNodes[34].initialX = 16000m
**.loRaNodes[34].initialY = 11000m

# Row 5 (7 nodes): 35-41
**.loRaNodes[35].initialX = 1000m
**.loRaNodes[35].initialY = 13500m
**.loRaNodes[36].initialX = 3500m
**.loRaNodes[36].initialY = 13500m
**.loRaNodes[37].initialX = 6000m
**.loRaNodes[37].initialY = 13500m
**.loRaNodes[38].initialX = 8500m
**.loRaNodes[38].initialY = 13500m
**.loRaNodes[39].initialX = 11000m
**.loRaNodes[39].initialY = 13500m
**.loRaNodes[40].initialX = 13500m
**.loRaNodes[40].initialY = 13500m
**.loRaNodes[41].initialX = 16000m
**.loRaNodes[41].initialY = 13500m

# Row 6 (7 nodes): 42-48
**.loRaNodes[42].initialX = 1000m
**.loRaNodes[42].initialY = 16000m
**.loRaNodes[43].initialX = 3500m
**.loRaNodes[43].initialY = 16000m
**.loRaNodes[44].initialX = 6000m
**.loRaNodes[44].initialY = 16000m
**.loRaNodes[45].initialX = 8500m
**.loRaNodes[45].initialY = 16000m
**.loRaNodes[46].initialX = 11000m
**.loRaNodes[46].initialY = 16000m
**.loRaNodes[47].initialX = 13500m
**.loRaNodes[47].initialY = 16000m
**.loRaNodes[48].initialX = 16000m
**.loRaNodes[48].initialY = 16000m

# Row 7 (1 node): 49 (center node for interesting routing patterns)
**.loRaNodes[49].initialX = 8500m
**.loRaNodes[49].initialY = 18500m

	
# Number of nodes - 50 relay nodes in grid formation
**.numberOfNodes = 50         # 50 relay nodes for comprehensive routing demo
**.numberOfEndNodes = 0       # No regular end nodes (using rescue nodes instead)
**.numberOfRescueNodes = 2    # Two RESCUE end nodes for this scenario
# power consumption features
**.loRaNodes[*].LoRaNic.radio.energyConsumerType = "LoRaEnergyConsumer"
**.loRaNodes[*].**.energySourceModule = "IdealEpEnergyStorage"
**.loRaNodes[*].LoRaNic.radio.energyConsumer.configFile = xmldoc("energyConsumptionParameters.xml")
**.loRaRescueNodes[*].LoRaNic.radio.energyConsumerType = "LoRaEnergyConsumer"
**.loRaRescueNodes[*].**.energySourceModule = "IdealEpEnergyStorage"
**.loRaRescueNodes[*].LoRaNic.radio.energyConsumer.configFile = xmldoc("energyConsumptionParameters.xml")

# general network features
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
**.constraintAreaMaxX = 20000m  # 20km x 20km area
**.constraintAreaMaxY = 20000m
**.constraintAreaMaxZ = 0m
**.delayer.config = xmldoc("cloudDelays.xml")
**.radio.radioMediumModule = "LoRaMedium"
**.LoRaMedium.pathLossType = "LoRaLogNormalShadowing"

**.d0=190m
**.sigma = 3.5
**.gamma = 3.3

**.minInterferenceTime = 0s

# network features
**.numberOfGateways = 0

# =================================================================
# COMMUNICATION PATTERN FOR ROUTING DEMONSTRATION  
# =================================================================

# -----------------------------------------------------------------
# AUTOMATIC ACK FUNCTIONALITY
# When a DATA packet reaches its destination node, the destination
# will automatically generate an ACK packet back to the source using
# the routing tables. ACK packets are forwarded by intermediate nodes
# just like DATA packets, using the same routing algorithms.
# This enables end-to-end acknowledgment in multi-hop scenarios.
# -----------------------------------------------------------------

# data packets generation - disable relay generation, only rescue end nodes communicate
**.sendPacketsContinuously = false #relay nodes don't generate packets

# ROUTING DEMO: Disable relay data generation, only end-to-end communication
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = false  #relays don't generate data packets

# COMMUNICATION :
**.numberOfDestinationsPerNode = 1 #Each node talks to 1 specific destination
**.dataPacketDefaultSize = 11B  #packet size
**.packetTTL = 20 #Sufficient TTL for long multi-hop paths

**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 60s    # Start data after 1 minute
**.loRaRescueNodes[*].LoRaNodeApp.timeToFirstDataPacket = 60s    # Align end-node data start

**.timeToNextDataPacketDist = "uniform"
**.timeToNextDataPacketMin = 0s

**.timeToNextDataPacketMax = ${timeToNextDataPacketMax=10s}  # data packets are created every 1-10Secs

**.timeToNextDataPacketAvg = 5s   # Data every 5 seconds for easy observation

# forwarded packets
**.numberOfPacketsToForward = 0 #0 for no limit
**.ownDataPriority = 0 #0: forward priority; 1: own data priority

**.loRaNodes[*].LoRaNodeApp.routingMetric = 3  # HOP_COUNT routing - relay nodes use unicast with routing tables

# routing settings - ENHANCED FOR ROUTING DEMO
**.routeDiscovery = true
**.routeTimeout = 600s                 # Longer route validity for stability
**.storeBestRouteOnly = true           # Keep only the best route per destination
**.getRoutesFromDataPackets = true    # Learn from all packets
**.routingPacketPriority = 0.5
**.routingPacketMaxSize = 12B
**.timeToFirstRoutingPacket = 5s+uniform(0s, 5s)   # Start routing discovery immediately
**.timeToNextRoutingPacketDist = "uniform"
**.timeToNextRoutingPacketMin = 0s
**.timeToNextRoutingPacketMax = 10s    # Very frequent routing updates
**.timeToNextRoutingPacketAvg = 5s

# -----------------------------------------------------------------
# ROUTING TABLE FREEZE (stabilize topology after convergence)
# When enabled, once a node learns routingFreezeUniqueCount unique
# destination entries in its single-metric routing table, it will:
#  - Log REACHED<threshold> and FREEZE events to delivered_packets/routing_convergence.csv
#  - Stop accepting further routing updates / changes
#  - Preserve existing routes indefinitely (validity extended far future)
# This allows performance evaluation with a stable routing snapshot.
# Disable (false) to allow uous adaptation.
# -----------------------------------------------------------------
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = true
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 51   # Require unique routes to all other 49 nodes
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s  # How long to keep frozen routes valid (avoid huge like 1e9s)
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true  # Stop routing beacons when all nodes have unique routes to all destinations

# duty cycle
**.dutyCycle = 0.01
**.enforceDutyCycle = ${enforceDutyCycle = true, false}

# nodes placement (overridden by individual positions above)
**.loRaNodes[*].minX = 0m
**.loRaNodes[*].minY = 0m
**.loRaNodes[*].maxX = 20000m 
**.loRaNodes[*].maxY = 20000m 

# Random placement for RESCUE end nodes on every run (circle deployment)
**.loRaRescueNodes[*].deploymentType = "circle"
**.loRaRescueNodes[*].rad = 9000
**.loRaRescueNodes[*].centX = 10000
**.loRaRescueNodes[*].centY = 10000
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 3   # End nodes use same routing as relays (HOP_COUNT) for proper unicast forwarding
**.loRaRescueNodes[*].iAmRescue = true   # Identify rescue nodes; nodeId offsets to 2000+
 



**.LoRaMedium.mediumLimitCacheType = "LoRaMediumCache"
**.LoRaMedium.rangeFilter = "communicationRange"
**.LoRaMedium.neighborCacheType = "LoRaNeighborCache"
**.LoRaMedium.neighborCache.range = 3000m  # Suitable for 2.5km grid spacing
**.LoRaMedium.neighborCache.refillPeriod = 3000s

# LoRa settings: channel
**.loRaNodes[*].**.initFromDisplayString = false
**.loRaNodes[*].**initialLoRaSF = 7
**.loRaNodes[*].**minLoRaSF = 7
**.loRaNodes[*].**maxLoRaSF = 12
**.loRaNodes[*].**initialLoRaBW = 125 kHz
**.loRaNodes[*].**initialLoRaCR = 1
**.loRaNodes[*].**initialLoRaTP = 17dBm
**.loRaNodes[*].**initialLoRaCAD = true
**.loRaNodes[*].**initialLoRaCADatt = 0dB

# Rescue end-node radio initialization aligned with relay nodes
**.loRaRescueNodes[*].**.initFromDisplayString = false
**.loRaRescueNodes[*].**initialLoRaSF = 7
**.loRaRescueNodes[*].**minLoRaSF = 7
**.loRaRescueNodes[*].**maxLoRaSF = 12
**.loRaRescueNodes[*].**initialLoRaBW = 125 kHz
**.loRaRescueNodes[*].**initialLoRaCR = 1
**.loRaRescueNodes[*].**initialLoRaTP = 17dBm
**.loRaRescueNodes[*].**initialLoRaCAD = true
**.loRaRescueNodes[*].**initialLoRaCADatt = 0dB

# =================================================================
# END-TO-END COMMUNICATION: Rescue node 2000 floods to reach 2001
# Rescue end node 0 (ID 2000) continuously sends data to rescue end node 1 (ID 2001)
# End nodes must use FLOODING (routingMetric=1) so the initial TX is broadcast.
# Relays also use FLOODING (routingMetric=1) to rebroadcast and propagate the packet.
# =================================================================
**.loRaRescueNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true
**.loRaRescueNodes[0].LoRaNodeApp.sendPacketsContinuously = true
**.loRaRescueNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaRescueNodes[0].LoRaNodeApp.forcedDestinationId = 2001
**.loRaRescueNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaRescueNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 1
**.loRaRescueNodes[0].LoRaNodeApp.timeToFirstDataPacket = 60s    # Start after minimal warmup
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 15s   # Send every 10-15 seconds  
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 12s

# Ensure the other rescue end node doesn't generate traffic
**.loRaRescueNodes[1].LoRaNodeApp.sendPacketsContinuously = false

# FLOODING MODE: ensure broadcast behavior
**.routeDiscovery = false                       # No routing beacons in flooding
**.loRaNodes[*].LoRaNodeApp.routingMetric = 1   # Relays flood/broadcast
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 1 # End nodes flood TX (no forwarding implied by iAmEnd + no-forward checks)

# =================================================================
# ROUTING ALGORITHM CONFIGURATIONS FOR EASY TESTING
# =================================================================

[Config HopCount_Routing] 
# Minimum hop count - Shortest path
**.loRaNodes[*].LoRaNodeApp.routingMetric = 3

[Config ETX_Routing]
# ETX (Expected Transmission Count) - reliability-based routing
**.loRaNodes[*].LoRaNodeApp.routingMetric = 6

[Config RSSI_Routing]
# RSSI-based routing - signal strength
**.loRaNodes[*].LoRaNodeApp.routingMetric = 4

# =================================================================
# QUICK DEMO CONFIGURATIONS
# =================================================================

[Config QuickDemo_HopCount_Grid50]
extends = HopCount_Routing  
# Ultra-fast hop count routing demo with 50-node grid
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 3s
**.timeToNextRoutingPacketAvg = 2s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 150s
**.timeToNextDataPacketMax = 8s
**.timeToNextDataPacketAvg = 5s
warmup-period = 0s
sim-time-limit = 2000s

# Communication pattern - corner to corner communication
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true     
**.numberOfDestinationsPerNode = 1
**.sendPacketsContinuously = false

# Corner-to-corner communication: node 0 (bottom-left) to node 48 (top-right)
**.loRaNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaNodes[0].LoRaNodeApp.forcedDestinationId = 5

# Routing freeze settings for grid
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false  # Disable for quick demo
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 49
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s
#-------------------------------------------------------------------------------------------

# =================================================================
# REACHABILITY TEST: Node 0 to All Other Nodes (1-49)  
# =================================================================
[Config Node0ToAllNodes_Test]
extends = HopCount_Routing
# Test configuration to send packets from node 0 to every other node
# This will help identify which nodes are unreachable from node 0

# Only node 0 sends packets
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true     
**.numberOfDestinationsPerNode = 0  # 0 means all other nodes (auto-selected)
**.sendPacketsContinuously = true   # Keep sending packets

# Timing: Give routing time to converge, then start data transmission
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 50s
**.timeToNextRoutingPacketAvg = 45s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 150s     # Start data after routing converges

# Send packets with sufficient spacing
**.timeToNextDataPacketMax = 20s     # 10 seconds between packets 
**.timeToNextDataPacketAvg = 15s      # Average 8 seconds

# Routing settings optimized for reachability test
# Routing freeze settings for grid
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false  # Disable for quick demo
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 51
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s
**.routeTimeout = 800s               # Long route validity
**.packetTTL = 25                   # High TTL for long multi-hop paths

**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true  # Stop routing beacons when all nodes have unique routes to all destinations

# Extended simulation time to complete all transmissions
sim-time-limit = 2000s              # Shorter time first to test
warmup-period = 0s

# Duty cycle settings - disable to avoid interference with systematic testing
**.enforceDutyCycle = false         # Disable for comprehensive reachability test

# =================================================================
# SINGLE PACKET PER DESTINATION: Node 0 to All Other Nodes (1-49)  
# =================================================================
[Config Node0ToAllNodes_SinglePacket]
extends = HopCount_Routing
# Send exactly ONE packet from node 0 to each of the 49 destinations
# No continuous transmission - just one round of packets

# Only node 0 sends packets
**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true     
**.numberOfDestinationsPerNode = 0  # 0 means all other nodes (auto-selected)
**.sendPacketsContinuously = false  # CRITICAL: Send only initial batch, no continuous packets
**.numberOfPacketsPerDestination = 1  # Exactly 1 packet per destination

# Use a different result file name to avoid conflicts
output-scalar-file = "Node0_SinglePacket_${configname}_${datetime}.sca"
output-vector-file = "Node0_SinglePacket_${configname}_${datetime}.vec"

# Timing: Give routing time to converge, then send all packets quickly
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 3s
**.timeToNextRoutingPacketAvg = 2s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 200s     # Start data after routing converges

# Since sendPacketsContinuously=false, these timing parameters won't be used for additional packets
**.timeToNextDataPacketMax = 10s      # Not used with sendPacketsContinuously=false
**.timeToNextDataPacketAvg = 10s      # Not used with sendPacketsContinuously=false

# Routing settings optimized for reachability test
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false  # Keep adapting for reliability
**.routeTimeout = 800s               # Long route validity
**.packetTTL = 25                   # High TTL for long multi-hop paths

# Shorter simulation time since we only send 49 packets total
sim-time-limit = 600s               # Sufficient time for all 49 packets to be delivered
warmup-period = 0s

# Duty cycle settings - disable to avoid interference with systematic testing
**.enforceDutyCycle = false         # Disable for single-packet reachability test

# =================================================================
# SIMPLE TEST: Node 0 to Specific Nodes (Manual Testing)
# =================================================================
[Config Node0ToNode5_Simple]
extends = HopCount_Routing
# Simple test to verify the configuration works - send from node 0 to node 10
# Ultra-fast hop count routing demo with 50-node grid
**.timeToFirstRoutingPacket = 1s
**.timeToNextRoutingPacketMax = 3s
**.timeToNextRoutingPacketAvg = 2s
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 150s
**.timeToNextDataPacketMax = 8s
**.timeToNextDataPacketAvg = 5s
warmup-period = 0s
sim-time-limit = 2000s

**.loRaNodes[*].LoRaNodeApp.onlyNode0SendsPackets = true
**.numberOfDestinationsPerNode = 1
**.sendPacketsContinuously = false

**.loRaNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaNodes[0].LoRaNodeApp.forcedDestinationId = 5
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = false
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 16   # Adjust if you want earlier/later freeze
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s


# =================================================================
#End1000 generates, relays smart-broadcast to End1001 (RESCUE)
# - Preserve existing 50 relay nodes + 2 rescue end nodes placement from base
# - No routing beacons (pure data-plane forwarding)
# - Rescue end nodes do not forward (iAmEnd=true); only 1000 generates data
# - Relays forward with SMART_BROADCAST until destination 1001 receives
# =================================================================
[Config No_Duplicate_flood_End1000_to_End1001]
# Keep node counts and base placements as defined in General
network = LoRaMesh
**.numberOfNodes = 50
**.numberOfRescueNodes = 2

# Disable routing beacons to match Wellington behavior
**.routeDiscovery = false

# Relays use SMART_BROADCAST; Rescue end nodes are marked as end (no forwarding)
**.loRaNodes[*].LoRaNodeApp.routingMetric = 2      # SMART_BROADCAST_SINGLE_SF for relays
**.loRaRescueNodes[*].iAmRescue = true             # Rescue classification for 2000+ ID offset
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 1   # Flood TX from end nodes; forwarding still blocked by iAmEnd

# Ensure only rescue end node 0 generates data to rescue end node 1
**.sendPacketsContinuously = false                  # Relays do not generate data
**.loRaRescueNodes[1].LoRaNodeApp.sendPacketsContinuously = false
**.loRaRescueNodes[0].LoRaNodeApp.sendPacketsContinuously = true
**.loRaRescueNodes[0].LoRaNodeApp.timeToFirstDataPacket = 120s
**.loRaRescueNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaRescueNodes[0].LoRaNodeApp.forcedDestinationId = 2001
**.loRaRescueNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaRescueNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 1
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 15s
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 12s

# General data-plane parameters similar to Wellington
# Do NOT set a global numberOfDestinationsPerNode here; it can
# cause relays to generate a one-off packet at their timeToFirstDataPacket.
**.dataPacketDefaultSize = 11B
**.packetTTL = 20

# Explicitly prevent relay data generation (one-shot or continuous)
**.loRaNodes[*].LoRaNodeApp.sendPacketsContinuously = false
**.loRaNodes[*].LoRaNodeApp.numberOfPacketsPerDestination = 0
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 1000000s

# Optional: keep duty cycle as per base; uncomment to disable during tests
#**.enforceDutyCycle = false

# Recording for path analysis (optional; rely on existing logging setup)
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true

# Reasonable simulation time window
sim-time-limit = 1000s
warmup-period = 0s


# =================================================================
# MOBILITY VARIANT: Same as DV_End1000_to_End1001 but with mobility
# Enables MassMobility for rescue end nodes so they move during the
# simulation within the global constraint area already defined above.
# =================================================================
[Config DV_End1000_to_End1001_Mobility]
extends = DV_End1000_to_End1001

# Switch rescue nodes to a mobility model and set higher, more-dynamic speed
**.loRaRescueNodes[*].mobilityType = "MassMobility"
# Use randomized speeds between 3--7 m/s for more variation
**.loRaRescueNodes[*].mobility.speed = uniform(3mps, 7mps)
# Make direction changes more frequent and larger so nodes move more dynamically
**.loRaRescueNodes[*].mobility.changeInterval = 5s
**.loRaRescueNodes[*].mobility.angleDelta = uniform(-180deg, 180deg)

# (Optional) If you prefer a single fixed higher speed, replace the above `uniform(...)` with a literal, e.g. `5mps`.

# Start MassMobility from the same circle distribution as end nodes
# Start MassMobility from the same circle distribution as end nodes
# Use radians directly (avoid rad() conversion): angle ~ U(0, 2*pi)
**.loRaRescueNodes[*].mobility.initialX = 10000m + sqrt(uniform(0,1)) * 9000m * cos(uniform(0, 2*acos(-1)))
**.loRaRescueNodes[*].mobility.initialY = 10000m + sqrt(uniform(0,1)) * 9000m * sin(uniform(0, 2*acos(-1)))

# =================================================================
# FLOODING: 4 Pairs Simultaneous (Clean Config)
# Four rescue end-node pairs (1000→1001, 1002→1003, 1004→1005, 1006→1007)
# transmit simultaneously. Relays flood (metric 1), end nodes use
# smart broadcast (metric 2). Rescue end nodes placed randomly each run.
# =================================================================
[Config Flooding_4Pairs_Clean]
network = LoRaMesh

# Node counts
**.numberOfNodes = 50
**.numberOfRescueNodes = 8   # Rescue IDs will map to 2000..2007

# Logging
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true

# Disable routing beacons (pure flooding)
**.routeDiscovery = false

# Forwarding behavior: relays flood (1), end nodes smart broadcast (2)
**.loRaNodes[*].LoRaNodeApp.routingMetric = 2 # SMART_BROADCAST_SINGLE_SF
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 1 # FLOODING_BROADCAST_SINGLE_SF
**.loRaRescueNodes[*].iAmRescue = true

# Prevent relay data generation
**.sendPacketsContinuously = false
**.loRaNodes[*].LoRaNodeApp.sendPacketsContinuously = false
**.loRaNodes[*].LoRaNodeApp.numberOfPacketsPerDestination = 0
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Rescue end-node placement (random circle each run)
**.loRaRescueNodes[*].deploymentType = "circle"
**.loRaRescueNodes[*].rad = 9000
**.loRaRescueNodes[*].centX = 10000
**.loRaRescueNodes[*].centY = 10000
**.loRaRescueNodes[*].**.initFromDisplayString = false

# Common packet settings
**.dataPacketDefaultSize = 11B
**.packetTTL = 20
**.timeToNextDataPacketDist = "uniform"
**.timeToNextDataPacketMin = 0s

# Simultaneous start time for all senders
**.loRaRescueNodes[*].LoRaNodeApp.sendPacketsContinuously = false
**.loRaRescueNodes[*].LoRaNodeApp.numberOfPacketsPerDestination = 1
**.loRaRescueNodes[*].LoRaNodeApp.timeToFirstDataPacket = 120s

# Guardrail: default no destinations for all end nodes
**.loRaRescueNodes[*].LoRaNodeApp.numberOfDestinationsPerNode = 0

# Pair 0: 2000 → 2001 (end node indices 0 → 1)
**.loRaRescueNodes[0].LoRaNodeApp.sendPacketsContinuously = false
**.loRaRescueNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaRescueNodes[0].LoRaNodeApp.timeToFirstDataPacket = 120s
**.loRaRescueNodes[0].LoRaNodeApp.forcedDestinationId = 2001
**.loRaRescueNodes[0].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaRescueNodes[0].LoRaNodeApp.numberOfPacketsPerDestination = 1
**.loRaRescueNodes[1].LoRaNodeApp.sendPacketsContinuously = false
**.loRaRescueNodes[1].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Pair 1: 2002 → 2003
**.loRaRescueNodes[2].LoRaNodeApp.forceSingleDestination = true
**.loRaRescueNodes[2].LoRaNodeApp.forcedDestinationId = 2003
**.loRaRescueNodes[2].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaRescueNodes[3].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Pair 2: 2004 → 2005
**.loRaRescueNodes[4].LoRaNodeApp.forceSingleDestination = true
**.loRaRescueNodes[4].LoRaNodeApp.forcedDestinationId = 2005
**.loRaRescueNodes[4].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaRescueNodes[5].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Pair 3: 2006 → 2007
**.loRaRescueNodes[6].LoRaNodeApp.forceSingleDestination = true
**.loRaRescueNodes[6].LoRaNodeApp.forcedDestinationId = 2007
**.loRaRescueNodes[6].LoRaNodeApp.numberOfDestinationsPerNode = 1
**.loRaRescueNodes[7].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Simulation time
sim-time-limit = 1000s
warmup-period = 0s

# =================================================================
# END-TO-END: Rescue end node 1000 continuously sends to 1001
# End nodes broadcast, relays forward using unicast routing tables
# =================================================================
[Config DV_End1000_to_End1001]
extends = HopCount_Routing

# Keep routing behavior and logging as in base
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true

# Switch rescue nodes to a mobility model and set basic speed
**.loRaRescueNodes[*].mobilityType = "MassMobility"
**.loRaRescueNodes[*].mobility.speed = 2mps
# Optional: tweak mobility randomness
**.loRaRescueNodes[*].mobility.changeInterval = 20s
**.loRaRescueNodes[*].mobility.angleDelta = uniform(-30deg, 30deg)



# Ensure mobility does not use display-string positions (prevents top-left clustering)
**.loRaRescueNodes[*].**.initFromDisplayString = false


**.loRaNodes[*].LoRaNodeApp.recordPerPacketSignals = false
**.loRaRescueNodes[*].LoRaNodeApp.recordPerPacketSignals = false


# Stop routing beacons after relay convergence; keep forwarding enabled
**.loRaNodes[*].LoRaNodeApp.freezeRoutingAtThreshold = true
**.loRaNodes[*].LoRaNodeApp.routingFreezeUniqueCount = 3
**.loRaNodes[*].LoRaNodeApp.freezeValidityHorizon = 10000000s
**.loRaNodes[*].LoRaNodeApp.stopRoutingWhenAllConverged = true

# Enable continuous data generation from rescue end node 0 (ID 2000) to rescue end node 1 (ID 2001)
**.sendPacketsContinuously = false  # Relays don't generate data

# Disable data generation for relay nodes and unwanted end nodes
**.loRaNodes[*].LoRaNodeApp.timeToFirstDataPacket = 1e6s
**.loRaRescueNodes[1].LoRaNodeApp.timeToFirstDataPacket = 1e6s

# Enable continuous data generation only at rescue end node 0 (ID 2000)
**.loRaRescueNodes[0].LoRaNodeApp.sendPacketsContinuously = false
**.loRaRescueNodes[0].LoRaNodeApp.timeToFirstDataPacket = 120s
**.loRaRescueNodes[0].LoRaNodeApp.forceSingleDestination = true
**.loRaRescueNodes[0].LoRaNodeApp.forcedDestinationId = 2001
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketMax = 20s
**.loRaRescueNodes[0].LoRaNodeApp.timeToNextDataPacketAvg = 15s

# Longer simulation to observe multiple packet exchanges
#sim-time-limit = 1000s

# Ensure end nodes participate in routing beacons so relays can learn routes to 2000/2001
**.loRaRescueNodes[*].LoRaNodeApp.routingMetric = 3
# Minimum hop count - Shortest path
**.loRaNodes[*].LoRaNodeApp.routingMetric = 3

# Timing for routing beacons so routes propagate before the data
**.timeToFirstRoutingPacket = 5s
**.timeToNextRoutingPacketMax = 10s
**.timeToNextRoutingPacketAvg = 5s

# Reasonable simulation time
sim-time-limit = 1000s
warmup-period = 0s


# =================================================================
# FIXED-DISTANCE VARIANT: Rescue end nodes at fixed, reproducible coordinates
# Keeps routing and data behavior identical to End1000_to_End1001,
# but overrides end-node placement to achieve a fixed separation.
# =================================================================
[Config End1000_to_End1001_FixedDistance]
extends = DV_End1000_to_End1001

# Override rescue end-node deployment to manual fixed positions
**.loRaRescueNodes[*].deploymentType = "manual"
**.loRaRescueNodes[*].iAmRescue = true
**.loRaRescueNodes[*].**.initFromDisplayString = false

# Set exact coordinates (example: ~13.436 km separation on diagonal)
# Adjust these to any fixed positions you prefer.
**.loRaRescueNodes[0].initialX = 16162.18m
**.loRaRescueNodes[0].initialY = 10449.97m
**.loRaRescueNodes[1].initialX = 5089.39m
**.loRaRescueNodes[1].initialY = 2838.48m

# Ensure relays keep their grid and routing behavior from base config
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true

# =================================================================
# FIXED-DISTANCE VARIANT: No_Duplicate_End1000_to_End1001
# Keeps data-plane behavior identical to No_Duplicate_End1000_to_End1001,
# but overrides rescue end-node placement to achieve the same fixed separation
# used in End1000_to_End1001_FixedDistance.
# =================================================================
[Config No_Duplicate_End1000_to_End1001_FixedDistance]
extends = No_Duplicate_flood_End1000_to_End1001

# Override rescue end-node deployment to manual fixed positions
**.loRaRescueNodes[*].deploymentType = "manual"
**.loRaRescueNodes[*].iAmRescue = true
**.loRaRescueNodes[*].**.initFromDisplayString = false

# Set exact coordinates (same as End1000_to_End1001_FixedDistance)
**.loRaRescueNodes[0].initialX = 16162.18m
**.loRaRescueNodes[0].initialY = 10449.97m
**.loRaRescueNodes[1].initialX = 5089.39m
**.loRaRescueNodes[1].initialY = 2838.48m

# Ensure relays keep their grid and recording behavior from base config
record-eventlog = true
**.vector-recording = true
**.scalar-recording = true
